{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"cose-base\"));else if (typeof define === 'function' && define.amd) define([\"cose-base\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));else root[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(self, function (__WEBPACK_EXTERNAL_MODULE__281__) {\n  return /******/(() => {\n    // webpackBootstrap\n    /******/\n    \"use strict\";\n\n    /******/\n    var __webpack_modules__ = {\n      /***/658: (/***/module => {\n        // Simple, internal Object.assign() polyfill for options objects etc.\n\n        module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n          for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            srcs[_key - 1] = arguments[_key];\n          }\n          srcs.forEach(function (src) {\n            Object.keys(src).forEach(function (k) {\n              return tgt[k] = src[k];\n            });\n          });\n          return tgt;\n        };\n\n        /***/\n      }),\n      /***/548: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        /*\n         * Auxiliary functions\n         */\n\n        var LinkedList = __webpack_require__(281).layoutBase.LinkedList;\n        var auxiliary = {};\n\n        // get the top most nodes\n        auxiliary.getTopMostNodes = function (nodes) {\n          var nodesMap = {};\n          for (var i = 0; i < nodes.length; i++) {\n            nodesMap[nodes[i].id()] = true;\n          }\n          var roots = nodes.filter(function (ele, i) {\n            if (typeof ele === \"number\") {\n              ele = i;\n            }\n            var parent = ele.parent()[0];\n            while (parent != null) {\n              if (nodesMap[parent.id()]) {\n                return false;\n              }\n              parent = parent.parent()[0];\n            }\n            return true;\n          });\n          return roots;\n        };\n\n        // find disconnected components and create dummy nodes that connect them\n        auxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n          var queue = new LinkedList();\n          var visited = new Set();\n          var visitedTopMostNodes = [];\n          var currentNeighbor = void 0;\n          var minDegreeNode = void 0;\n          var minDegree = void 0;\n          var isConnected = false;\n          var count = 1;\n          var nodesConnectedToDummy = [];\n          var components = [];\n          var _loop = function _loop() {\n            var cmpt = cy.collection();\n            components.push(cmpt);\n            var currentNode = topMostNodes[0];\n            var childrenOfCurrentNode = cy.collection();\n            childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n            visitedTopMostNodes.push(currentNode);\n            childrenOfCurrentNode.forEach(function (node) {\n              queue.push(node);\n              visited.add(node);\n              cmpt.merge(node);\n            });\n            var _loop2 = function _loop2() {\n              currentNode = queue.shift();\n\n              // Traverse all neighbors of this node\n              var neighborNodes = cy.collection();\n              currentNode.neighborhood().nodes().forEach(function (node) {\n                if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                  neighborNodes.merge(node);\n                }\n              });\n              for (var i = 0; i < neighborNodes.length; i++) {\n                var neighborNode = neighborNodes[i];\n                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                  var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                  childrenOfNeighbor.forEach(function (node) {\n                    queue.push(node);\n                    visited.add(node);\n                    cmpt.merge(node);\n                    if (topMostNodes.has(node)) {\n                      visitedTopMostNodes.push(node);\n                    }\n                  });\n                }\n              }\n            };\n            while (queue.length != 0) {\n              _loop2();\n            }\n            cmpt.forEach(function (node) {\n              eles.intersection(node.connectedEdges()).forEach(function (e) {\n                // connectedEdges() usually cached\n                if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                  // has() is cheap\n                  cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n                }\n              });\n            });\n            if (visitedTopMostNodes.length == topMostNodes.length) {\n              isConnected = true;\n            }\n            if (!isConnected || isConnected && count > 1) {\n              minDegreeNode = visitedTopMostNodes[0];\n              minDegree = minDegreeNode.connectedEdges().length;\n              visitedTopMostNodes.forEach(function (node) {\n                if (node.connectedEdges().length < minDegree) {\n                  minDegree = node.connectedEdges().length;\n                  minDegreeNode = node;\n                }\n              });\n              nodesConnectedToDummy.push(minDegreeNode.id());\n              // TO DO: Check efficiency of this part\n              var temp = cy.collection();\n              temp.merge(visitedTopMostNodes[0]);\n              visitedTopMostNodes.forEach(function (node) {\n                temp.merge(node);\n              });\n              visitedTopMostNodes = [];\n              topMostNodes = topMostNodes.difference(temp);\n              count++;\n            }\n          };\n          do {\n            _loop();\n          } while (!isConnected);\n          if (dummyNodes) {\n            if (nodesConnectedToDummy.length > 0) {\n              dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n            }\n          }\n          return components;\n        };\n        auxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n          // calculate bounds\n          var left = Number.MAX_SAFE_INTEGER;\n          var right = Number.MIN_SAFE_INTEGER;\n          var top = Number.MAX_SAFE_INTEGER;\n          var bottom = Number.MIN_SAFE_INTEGER;\n          var nodeLeft = void 0;\n          var nodeRight = void 0;\n          var nodeTop = void 0;\n          var nodeBottom = void 0;\n          var nodes = parentNode.descendants().not(\":parent\");\n          var s = nodes.length;\n          for (var i = 0; i < s; i++) {\n            var node = nodes[i];\n            nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n            nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n            nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n            nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n            if (left > nodeLeft) {\n              left = nodeLeft;\n            }\n            if (right < nodeRight) {\n              right = nodeRight;\n            }\n            if (top > nodeTop) {\n              top = nodeTop;\n            }\n            if (bottom < nodeBottom) {\n              bottom = nodeBottom;\n            }\n          }\n          var boundingBox = {};\n          boundingBox.topLeftX = left;\n          boundingBox.topLeftY = top;\n          boundingBox.width = right - left;\n          boundingBox.height = bottom - top;\n          return boundingBox;\n        };\n        module.exports = auxiliary;\n\n        /***/\n      }),\n      /***/816: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        /**\n          The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n        */\n\n        var aux = __webpack_require__(548);\n        var CoSELayout = __webpack_require__(281).CoSELayout;\n        var CoSENode = __webpack_require__(281).CoSENode;\n        var PointD = __webpack_require__(281).layoutBase.PointD;\n        var DimensionD = __webpack_require__(281).layoutBase.DimensionD;\n        var LayoutConstants = __webpack_require__(281).layoutBase.LayoutConstants;\n        var FDLayoutConstants = __webpack_require__(281).layoutBase.FDLayoutConstants;\n        var CoSEConstants = __webpack_require__(281).CoSEConstants;\n\n        // main function that cose layout is processed\n        var coseLayout = function coseLayout(options, spectralResult) {\n          var eles = options.eles;\n          var nodes = eles.nodes();\n          var edges = eles.edges();\n          var nodeIndexes = void 0;\n          var xCoords = void 0;\n          var yCoords = void 0;\n          var idToLNode = {};\n          if (options.randomize) {\n            nodeIndexes = spectralResult[\"nodeIndexes\"];\n            xCoords = spectralResult[\"xCoords\"];\n            yCoords = spectralResult[\"yCoords\"];\n          }\n          var isFn = function isFn(fn) {\n            return typeof fn === 'function';\n          };\n          var optFn = function optFn(opt, ele) {\n            if (isFn(opt)) {\n              return opt(ele);\n            } else {\n              return opt;\n            }\n          };\n\n          /**** Postprocessing functions ****/\n\n          // transfer cytoscape nodes to cose nodes\n          var processChildrenList = function processChildrenList(parent, children, layout, options) {\n            var size = children.length;\n            for (var i = 0; i < size; i++) {\n              var theChild = children[i];\n              var children_of_children = theChild.children();\n              var theNode = void 0;\n              var dimensions = theChild.layoutDimensions({\n                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n              });\n              if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                if (options.randomize) {\n                  if (!theChild.isParent()) {\n                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                  } else {\n                    var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n                  }\n                } else {\n                  theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                }\n              } else {\n                theNode = parent.add(new CoSENode(this.graphManager));\n              }\n              // Attach id to the layout node and repulsion value\n              theNode.id = theChild.data(\"id\");\n              theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n              // Attach the paddings of cy node to layout node\n              theNode.paddingLeft = parseInt(theChild.css('padding'));\n              theNode.paddingTop = parseInt(theChild.css('padding'));\n              theNode.paddingRight = parseInt(theChild.css('padding'));\n              theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n              //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n              //These properties will be used while updating bounds of compounds during iterations or tiling\n              //and will be used for simple nodes while transferring final positions to cytoscape\n              if (options.nodeDimensionsIncludeLabels) {\n                theNode.labelWidth = theChild.boundingBox({\n                  includeLabels: true,\n                  includeNodes: false,\n                  includeOverlays: false\n                }).w;\n                theNode.labelHeight = theChild.boundingBox({\n                  includeLabels: true,\n                  includeNodes: false,\n                  includeOverlays: false\n                }).h;\n                theNode.labelPosVertical = theChild.css(\"text-valign\");\n                theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n              }\n\n              // Map the layout node\n              idToLNode[theChild.data(\"id\")] = theNode;\n              if (isNaN(theNode.rect.x)) {\n                theNode.rect.x = 0;\n              }\n              if (isNaN(theNode.rect.y)) {\n                theNode.rect.y = 0;\n              }\n              if (children_of_children != null && children_of_children.length > 0) {\n                var theNewGraph = void 0;\n                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                processChildrenList(theNewGraph, children_of_children, layout, options);\n              }\n            }\n          };\n\n          // transfer cytoscape edges to cose edges\n          var processEdges = function processEdges(layout, gm, edges) {\n            var idealLengthTotal = 0;\n            var edgeCount = 0;\n            for (var i = 0; i < edges.length; i++) {\n              var edge = edges[i];\n              var sourceNode = idToLNode[edge.data(\"source\")];\n              var targetNode = idToLNode[edge.data(\"target\")];\n              if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                e1.id = edge.id();\n                e1.idealLength = optFn(options.idealEdgeLength, edge);\n                e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                idealLengthTotal += e1.idealLength;\n                edgeCount++;\n              }\n            }\n            // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n            // in case there is no edge, use other options\n            if (options.idealEdgeLength != null) {\n              if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength))\n                // in case there is no edge, but option gives a value to use\n                CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else\n                // in case there is no edge and we cannot get a value from option (because it's a function)\n                CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n              // we need to update these constant values based on the ideal edge length constant\n              CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n              CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            }\n          };\n\n          // transfer cytoscape constraints to cose layout\n          var processConstraints = function processConstraints(layout, options) {\n            // get nodes to be fixed\n            if (options.fixedNodeConstraint) {\n              layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n            }\n            // get nodes to be aligned\n            if (options.alignmentConstraint) {\n              layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n            }\n            // get nodes to be relatively placed\n            if (options.relativePlacementConstraint) {\n              layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n            }\n          };\n\n          /**** Apply postprocessing ****/\n          if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n          if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n          if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n          if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n          if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n          if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n          if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n          if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n          CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n          CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n          CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n          CoSEConstants.TILE = options.tile;\n          CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n          CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n          CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n          CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n          LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n          // This part is for debug/demo purpose\n          if (options.step == \"transformed\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n            CoSEConstants.ENFORCE_CONSTRAINTS = false;\n            CoSEConstants.APPLY_LAYOUT = false;\n          }\n          if (options.step == \"enforced\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = true;\n            CoSEConstants.APPLY_LAYOUT = false;\n          }\n          if (options.step == \"cose\") {\n            CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = false;\n            CoSEConstants.APPLY_LAYOUT = true;\n          }\n          if (options.step == \"all\") {\n            if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n            CoSEConstants.ENFORCE_CONSTRAINTS = true;\n            CoSEConstants.APPLY_LAYOUT = true;\n          }\n          if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n          } else {\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n          }\n          var coseLayout = new CoSELayout();\n          var gm = coseLayout.newGraphManager();\n          processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n          processEdges(coseLayout, gm, edges);\n          processConstraints(coseLayout, options);\n          coseLayout.runLayout();\n          return idToLNode;\n        };\n        module.exports = {\n          coseLayout: coseLayout\n        };\n\n        /***/\n      }),\n      /***/212: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var _createClass = function () {\n          function defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n          return function (Constructor, protoProps, staticProps) {\n            if (protoProps) defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) defineProperties(Constructor, staticProps);\n            return Constructor;\n          };\n        }();\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n          }\n        }\n\n        /**\n          The implementation of the fcose layout algorithm\n        */\n\n        var assign = __webpack_require__(658);\n        var aux = __webpack_require__(548);\n        var _require = __webpack_require__(657),\n          spectralLayout = _require.spectralLayout;\n        var _require2 = __webpack_require__(816),\n          coseLayout = _require2.coseLayout;\n        var defaults = Object.freeze({\n          // 'draft', 'default' or 'proof' \n          // - 'draft' only applies spectral layout \n          // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n          // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n          quality: \"default\",\n          // Use random node positions at beginning of layout\n          // if this is set to false, then quality option must be \"proof\"\n          randomize: true,\n          // Whether or not to animate the layout\n          animate: true,\n          // Duration of animation in ms, if enabled\n          animationDuration: 1000,\n          // Easing of animation, if enabled\n          animationEasing: undefined,\n          // Fit the viewport to the repositioned nodes\n          fit: true,\n          // Padding around layout\n          padding: 30,\n          // Whether to include labels in node dimensions. Valid in \"proof\" quality\n          nodeDimensionsIncludeLabels: false,\n          // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n          uniformNodeDimensions: false,\n          // Whether to pack disconnected components - valid only if randomize: true\n          packComponents: true,\n          // Layout step - all, transformed, enforced, cose - for debug purpose only\n          step: \"all\",\n          /* spectral layout options */\n\n          // False for random, true for greedy\n          samplingType: true,\n          // Sample size to construct distance matrix\n          sampleSize: 25,\n          // Separation amount between nodes\n          nodeSeparation: 75,\n          // Power iteration tolerance\n          piTol: 0.0000001,\n          /* CoSE layout options */\n\n          // Node repulsion (non overlapping) multiplier\n          nodeRepulsion: function nodeRepulsion(node) {\n            return 4500;\n          },\n          // Ideal edge (non nested) length\n          idealEdgeLength: function idealEdgeLength(edge) {\n            return 50;\n          },\n          // Divisor to compute edge forces\n          edgeElasticity: function edgeElasticity(edge) {\n            return 0.45;\n          },\n          // Nesting factor (multiplier) to compute ideal edge length for nested edges\n          nestingFactor: 0.1,\n          // Gravity force (constant)\n          gravity: 0.25,\n          // Maximum number of iterations to perform\n          numIter: 2500,\n          // For enabling tiling\n          tile: true,\n          // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n          tilingPaddingVertical: 10,\n          // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n          tilingPaddingHorizontal: 10,\n          // Gravity range (constant) for compounds\n          gravityRangeCompound: 1.5,\n          // Gravity force (constant) for compounds\n          gravityCompound: 1.0,\n          // Gravity range (constant)\n          gravityRange: 3.8,\n          // Initial cooling factor for incremental layout  \n          initialEnergyOnIncremental: 0.3,\n          /* constraint options */\n\n          // Fix required nodes to predefined positions\n          // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n          fixedNodeConstraint: undefined,\n          // Align required nodes in vertical/horizontal direction\n          // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n          alignmentConstraint: undefined,\n          // Place two nodes relatively in vertical/horizontal direction \n          // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n          relativePlacementConstraint: undefined,\n          /* layout event callbacks */\n          ready: function ready() {},\n          // on layoutready\n          stop: function stop() {} // on layoutstop\n        });\n        var Layout = function () {\n          function Layout(options) {\n            _classCallCheck(this, Layout);\n            this.options = assign({}, defaults, options);\n          }\n          _createClass(Layout, [{\n            key: 'run',\n            value: function run() {\n              var layout = this;\n              var options = this.options;\n              var cy = options.cy;\n              var eles = options.eles;\n              var spectralResult = [];\n              var xCoords = void 0;\n              var yCoords = void 0;\n              var coseResult = [];\n              var components = void 0;\n\n              // basic validity check for constraint inputs \n              if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                options.fixedNodeConstraint = undefined;\n              }\n              if (options.alignmentConstraint) {\n                if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                  options.alignmentConstraint.vertical = undefined;\n                }\n                if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                  options.alignmentConstraint.horizontal = undefined;\n                }\n              }\n              if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                options.relativePlacementConstraint = undefined;\n              }\n\n              // if any constraint exists, set some options\n              var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n              if (constraintExist) {\n                // constraints work with these options\n                options.tile = false;\n                options.packComponents = false;\n              }\n\n              // decide component packing is enabled or not\n              var layUtil = void 0;\n              var packingEnabled = false;\n              if (cy.layoutUtilities && options.packComponents) {\n                layUtil = cy.layoutUtilities(\"get\");\n                if (!layUtil) layUtil = cy.layoutUtilities();\n                packingEnabled = true;\n              }\n              if (eles.nodes().length > 0) {\n                // if packing is not enabled, perform layout on the whole graph\n                if (!packingEnabled) {\n                  if (options.randomize) {\n                    var result = spectralLayout(options); // apply spectral layout        \n                    spectralResult.push(result);\n                  }\n                  // apply cose layout as postprocessing\n                  if (options.quality == \"default\" || options.quality == \"proof\") {\n                    coseResult.push(coseLayout(options, spectralResult[0]));\n                  }\n                } else {\n                  // packing is enabled\n                  var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                  components = aux.connectComponents(cy, options.eles, topMostNodes);\n\n                  //send each component to spectral layout\n                  if (options.randomize) {\n                    components.forEach(function (component) {\n                      options.eles = component;\n                      spectralResult.push(spectralLayout(options));\n                    });\n                  }\n                  if (options.quality == \"default\" || options.quality == \"proof\") {\n                    var toBeTiledNodes = cy.collection();\n                    if (options.tile) {\n                      // behave nodes to be tiled as one component\n                      var nodeIndexes = new Map();\n                      var _xCoords = [];\n                      var _yCoords = [];\n                      var count = 0;\n                      var tempSpectralResult = {\n                        nodeIndexes: nodeIndexes,\n                        xCoords: _xCoords,\n                        yCoords: _yCoords\n                      };\n                      var indexesToBeDeleted = [];\n                      components.forEach(function (component, index) {\n                        if (component.edges().length == 0) {\n                          component.nodes().forEach(function (node, i) {\n                            toBeTiledNodes.merge(component.nodes()[i]);\n                            if (!node.isParent()) {\n                              tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                              tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                              tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                            }\n                          });\n                          indexesToBeDeleted.push(index);\n                        }\n                      });\n                      if (toBeTiledNodes.length > 1) {\n                        components.push(toBeTiledNodes);\n                        spectralResult.push(tempSpectralResult);\n                        for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                          components.splice(indexesToBeDeleted[i], 1);\n                          spectralResult.splice(indexesToBeDeleted[i], 1);\n                        }\n                        ;\n                      }\n                    }\n                    components.forEach(function (component, index) {\n                      // send each component to cose layout\n                      options.eles = component;\n                      coseResult.push(coseLayout(options, spectralResult[index]));\n                    });\n                  }\n\n                  // packing\n                  if (components.length > 1) {\n                    var subgraphs = [];\n                    components.forEach(function (component, index) {\n                      var nodeIndexes = void 0;\n                      if (options.quality == \"draft\") {\n                        nodeIndexes = spectralResult[index].nodeIndexes;\n                      }\n                      var subgraph = {};\n                      subgraph.nodes = [];\n                      subgraph.edges = [];\n                      var nodeIndex = void 0;\n                      component.nodes().forEach(function (node) {\n                        if (options.quality == \"draft\") {\n                          if (!node.isParent()) {\n                            nodeIndex = nodeIndexes.get(node.id());\n                            subgraph.nodes.push({\n                              x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                              y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                              width: node.boundingbox().w,\n                              height: node.boundingbox().h\n                            });\n                          } else {\n                            var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                            subgraph.nodes.push({\n                              x: parentInfo.topLeftX,\n                              y: parentInfo.topLeftY,\n                              width: parentInfo.width,\n                              height: parentInfo.height\n                            });\n                          }\n                        } else {\n                          subgraph.nodes.push({\n                            x: coseResult[index][node.id()].getLeft(),\n                            y: coseResult[index][node.id()].getTop(),\n                            width: coseResult[index][node.id()].getWidth(),\n                            height: coseResult[index][node.id()].getHeight()\n                          });\n                        }\n                      });\n                      component.edges().forEach(function (edge) {\n                        var source = edge.source();\n                        var target = edge.target();\n                        if (options.quality == \"draft\") {\n                          var sourceNodeIndex = nodeIndexes.get(source.id());\n                          var targetNodeIndex = nodeIndexes.get(target.id());\n                          var sourceCenter = [];\n                          var targetCenter = [];\n                          if (source.isParent()) {\n                            var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                            sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                            sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                          } else {\n                            sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                            sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                          }\n                          if (target.isParent()) {\n                            var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                            targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                            targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                          } else {\n                            targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                            targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                          }\n                          subgraph.edges.push({\n                            startX: sourceCenter[0],\n                            startY: sourceCenter[1],\n                            endX: targetCenter[0],\n                            endY: targetCenter[1]\n                          });\n                        } else {\n                          subgraph.edges.push({\n                            startX: coseResult[index][source.id()].getCenterX(),\n                            startY: coseResult[index][source.id()].getCenterY(),\n                            endX: coseResult[index][target.id()].getCenterX(),\n                            endY: coseResult[index][target.id()].getCenterY()\n                          });\n                        }\n                      });\n                      subgraphs.push(subgraph);\n                    });\n                    var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                    if (options.quality == \"draft\") {\n                      spectralResult.forEach(function (result, index) {\n                        var newXCoords = result.xCoords.map(function (x) {\n                          return x + shiftResult[index].dx;\n                        });\n                        var newYCoords = result.yCoords.map(function (y) {\n                          return y + shiftResult[index].dy;\n                        });\n                        result.xCoords = newXCoords;\n                        result.yCoords = newYCoords;\n                      });\n                    } else {\n                      coseResult.forEach(function (result, index) {\n                        Object.keys(result).forEach(function (item) {\n                          var nodeRectangle = result[item];\n                          nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[index].dx, nodeRectangle.getCenterY() + shiftResult[index].dy);\n                        });\n                      });\n                    }\n                  }\n                }\n\n                // move graph to its original position because spectral moves it to origin\n                if (options.randomize && !options.fixedNodeConstraint) {\n                  var minXCoord = Number.POSITIVE_INFINITY;\n                  var maxXCoord = Number.NEGATIVE_INFINITY;\n                  var minYCoord = Number.POSITIVE_INFINITY;\n                  var maxYCoord = Number.NEGATIVE_INFINITY;\n                  if (options.quality == \"draft\") {\n                    spectralResult.forEach(function (result) {\n                      result.xCoords.forEach(function (value) {\n                        if (value < minXCoord) minXCoord = value;\n                        if (value > maxXCoord) maxXCoord = value;\n                      });\n                      result.yCoords.forEach(function (value) {\n                        if (value < minYCoord) minYCoord = value;\n                        if (value > maxYCoord) maxYCoord = value;\n                      });\n                    });\n                    var boundingBox = options.eles.boundingBox();\n                    var diffOnX = boundingBox.x1 + boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;\n                    var diffOnY = boundingBox.y1 + boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;\n                    spectralResult.forEach(function (result) {\n                      result.xCoords = result.xCoords.map(function (x) {\n                        return x + diffOnX;\n                      });\n                      result.yCoords = result.yCoords.map(function (y) {\n                        return y + diffOnY;\n                      });\n                    });\n                  } else {\n                    coseResult.forEach(function (result) {\n                      Object.keys(result).forEach(function (item) {\n                        var node = result[item];\n                        if (node.getCenterX() < minXCoord) minXCoord = node.getCenterX();\n                        if (node.getCenterX() > maxXCoord) maxXCoord = node.getCenterX();\n                        if (node.getCenterY() < minYCoord) minYCoord = node.getCenterY();\n                        if (node.getCenterY() > maxYCoord) maxYCoord = node.getCenterY();\n                      });\n                    });\n                    var _boundingBox = options.eles.boundingBox();\n                    var _diffOnX = _boundingBox.x1 + _boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;\n                    var _diffOnY = _boundingBox.y1 + _boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;\n                    coseResult.forEach(function (result, index) {\n                      Object.keys(result).forEach(function (item) {\n                        var node = result[item];\n                        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n                      });\n                    });\n                  }\n                }\n              }\n\n              // get each element's calculated position\n              var getPositions = function getPositions(ele, i) {\n                if (options.quality == \"default\" || options.quality == \"proof\") {\n                  if (typeof ele === \"number\") {\n                    ele = i;\n                  }\n                  var pos = void 0;\n                  var node = void 0;\n                  var theId = ele.data('id');\n                  coseResult.forEach(function (result) {\n                    if (theId in result) {\n                      pos = {\n                        x: result[theId].getRect().getCenterX(),\n                        y: result[theId].getRect().getCenterY()\n                      };\n                      node = result[theId];\n                    }\n                  });\n                  if (options.nodeDimensionsIncludeLabels) {\n                    if (node.labelWidth) {\n                      if (node.labelPosHorizontal == \"left\") {\n                        pos.x += node.labelWidth / 2;\n                      } else if (node.labelPosHorizontal == \"right\") {\n                        pos.x -= node.labelWidth / 2;\n                      }\n                    }\n                    if (node.labelHeight) {\n                      if (node.labelPosVertical == \"top\") {\n                        pos.y += node.labelHeight / 2;\n                      } else if (node.labelPosVertical == \"bottom\") {\n                        pos.y -= node.labelHeight / 2;\n                      }\n                    }\n                  }\n                  return {\n                    x: pos.x,\n                    y: pos.y\n                  };\n                } else {\n                  var _pos = void 0;\n                  spectralResult.forEach(function (result) {\n                    var index = result.nodeIndexes.get(ele.id());\n                    if (index != undefined) {\n                      _pos = {\n                        x: result.xCoords[index],\n                        y: result.yCoords[index]\n                      };\n                    }\n                  });\n                  if (_pos == undefined) _pos = {\n                    x: ele.position(\"x\"),\n                    y: ele.position(\"y\")\n                  };\n                  return {\n                    x: _pos.x,\n                    y: _pos.y\n                  };\n                }\n              };\n\n              // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n              if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n                options.eles = eles;\n                eles.nodes().not(\":parent\").layoutPositions(layout, options, getPositions);\n              } else {\n                console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n              }\n            }\n          }]);\n          return Layout;\n        }();\n        module.exports = Layout;\n\n        /***/\n      }),\n      /***/657: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        /**\n          The implementation of the spectral layout that is the first part of the fcose layout algorithm\n        */\n\n        var aux = __webpack_require__(548);\n        var Matrix = __webpack_require__(281).layoutBase.Matrix;\n        var SVD = __webpack_require__(281).layoutBase.SVD;\n\n        // main function that spectral layout is processed\n        var spectralLayout = function spectralLayout(options) {\n          var cy = options.cy;\n          var eles = options.eles;\n          var nodes = eles.nodes();\n          var parentNodes = eles.nodes(\":parent\");\n          var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n          var nodeIndexes = new Map(); // map to keep indexes to nodes\n          var parentChildMap = new Map(); // mapping btw. compound and its representative node \n          var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n          var xCoords = [];\n          var yCoords = [];\n          var samplesColumn = []; // sampled vertices\n          var minDistancesColumn = [];\n          var C = []; // column sampling matrix\n          var PHI = []; // intersection of column and row sampling matrices \n          var INV = []; // inverse of PHI \n\n          var firstSample = void 0; // the first sampled node\n          var nodeSize = void 0;\n          var infinity = 100000000;\n          var small = 0.000000001;\n          var piTol = options.piTol;\n          var samplingType = options.samplingType; // false for random, true for greedy\n          var nodeSeparation = options.nodeSeparation;\n          var sampleSize = void 0;\n\n          /**** Spectral-preprocessing functions ****/\n\n          /**** Spectral layout functions ****/\n\n          // determine which columns to be sampled\n          var randomSampleCR = function randomSampleCR() {\n            var sample = 0;\n            var count = 0;\n            var flag = false;\n            while (count < sampleSize) {\n              sample = Math.floor(Math.random() * nodeSize);\n              flag = false;\n              for (var i = 0; i < count; i++) {\n                if (samplesColumn[i] == sample) {\n                  flag = true;\n                  break;\n                }\n              }\n              if (!flag) {\n                samplesColumn[count] = sample;\n                count++;\n              } else {\n                continue;\n              }\n            }\n          };\n\n          // takes the index of the node(pivot) to initiate BFS as a parameter\n          var BFS = function BFS(pivot, index, samplingMethod) {\n            var path = []; // the front of the path\n            var front = 0; // the back of the path\n            var back = 0;\n            var current = 0;\n            var temp = void 0;\n            var distance = [];\n            var max_dist = 0; // the furthest node to be returned\n            var max_ind = 1;\n            for (var i = 0; i < nodeSize; i++) {\n              distance[i] = infinity;\n            }\n            path[back] = pivot;\n            distance[pivot] = 0;\n            while (back >= front) {\n              current = path[front++];\n              var neighbors = allNodesNeighborhood[current];\n              for (var _i = 0; _i < neighbors.length; _i++) {\n                temp = nodeIndexes.get(neighbors[_i]);\n                if (distance[temp] == infinity) {\n                  distance[temp] = distance[current] + 1;\n                  path[++back] = temp;\n                }\n              }\n              C[current][index] = distance[current] * nodeSeparation;\n            }\n            if (samplingMethod) {\n              for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n                if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n              }\n              for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n                if (minDistancesColumn[_i3] > max_dist) {\n                  max_dist = minDistancesColumn[_i3];\n                  max_ind = _i3;\n                }\n              }\n            }\n            return max_ind;\n          };\n\n          // apply BFS to all nodes or selected samples\n          var allBFS = function allBFS(samplingMethod) {\n            var sample = void 0;\n            if (!samplingMethod) {\n              randomSampleCR();\n\n              // call BFS\n              for (var i = 0; i < sampleSize; i++) {\n                BFS(samplesColumn[i], i, samplingMethod, false);\n              }\n            } else {\n              sample = Math.floor(Math.random() * nodeSize);\n              firstSample = sample;\n              for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n                minDistancesColumn[_i4] = infinity;\n              }\n              for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n                samplesColumn[_i5] = sample;\n                sample = BFS(sample, _i5, samplingMethod);\n              }\n            }\n\n            // form the squared distances for C\n            for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n              for (var j = 0; j < sampleSize; j++) {\n                C[_i6][j] *= C[_i6][j];\n              }\n            }\n\n            // form PHI\n            for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n              PHI[_i7] = [];\n            }\n            for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n              for (var _j = 0; _j < sampleSize; _j++) {\n                PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n              }\n            }\n          };\n\n          // perform the SVD algorithm and apply a regularization step\n          var sample = function sample() {\n            var SVDResult = SVD.svd(PHI);\n            var a_q = SVDResult.S;\n            var a_u = SVDResult.U;\n            var a_v = SVDResult.V;\n            var max_s = a_q[0] * a_q[0] * a_q[0];\n            var a_Sig = [];\n\n            //  regularization\n            for (var i = 0; i < sampleSize; i++) {\n              a_Sig[i] = [];\n              for (var j = 0; j < sampleSize; j++) {\n                a_Sig[i][j] = 0;\n                if (i == j) {\n                  a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n                }\n              }\n            }\n            INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n          };\n\n          // calculate final coordinates \n          var powerIteration = function powerIteration() {\n            // two largest eigenvalues\n            var theta1 = void 0;\n            var theta2 = void 0;\n\n            // initial guesses for eigenvectors\n            var Y1 = [];\n            var Y2 = [];\n            var V1 = [];\n            var V2 = [];\n            for (var i = 0; i < nodeSize; i++) {\n              Y1[i] = Math.random();\n              Y2[i] = Math.random();\n            }\n            Y1 = Matrix.normalize(Y1);\n            Y2 = Matrix.normalize(Y2);\n            var count = 0;\n            // to keep track of the improvement ratio in power iteration\n            var current = small;\n            var previous = small;\n            var temp = void 0;\n            while (true) {\n              count++;\n              for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n                V1[_i9] = Y1[_i9];\n              }\n              Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n              theta1 = Matrix.dotProduct(V1, Y1);\n              Y1 = Matrix.normalize(Y1);\n              current = Matrix.dotProduct(V1, Y1);\n              temp = Math.abs(current / previous);\n              if (temp <= 1 + piTol && temp >= 1) {\n                break;\n              }\n              previous = current;\n            }\n            for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n              V1[_i10] = Y1[_i10];\n            }\n            count = 0;\n            previous = small;\n            while (true) {\n              count++;\n              for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n                V2[_i11] = Y2[_i11];\n              }\n              V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n              Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n              theta2 = Matrix.dotProduct(V2, Y2);\n              Y2 = Matrix.normalize(Y2);\n              current = Matrix.dotProduct(V2, Y2);\n              temp = Math.abs(current / previous);\n              if (temp <= 1 + piTol && temp >= 1) {\n                break;\n              }\n              previous = current;\n            }\n            for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n              V2[_i12] = Y2[_i12];\n            }\n\n            // theta1 now contains dominant eigenvalue\n            // theta2 now contains the second-largest eigenvalue\n            // V1 now contains theta1's eigenvector\n            // V2 now contains theta2's eigenvector\n\n            //populate the two vectors\n            xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n            yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n          };\n\n          /**** Preparation for spectral layout (Preprocessing) ****/\n\n          // connect disconnected components (first top level, then inside of each compound node)\n          aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n          parentNodes.forEach(function (ele) {\n            aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n          });\n\n          // assign indexes to nodes (first real, then dummy nodes)\n          var index = 0;\n          for (var i = 0; i < nodes.length; i++) {\n            if (!nodes[i].isParent()) {\n              nodeIndexes.set(nodes[i].id(), index++);\n            }\n          }\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n          try {\n            for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var key = _step.value;\n              nodeIndexes.set(key, index++);\n            }\n\n            // instantiate the neighborhood matrix\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n            allNodesNeighborhood[_i13] = [];\n          }\n\n          // form a parent-child map to keep representative node of each compound node  \n          parentNodes.forEach(function (ele) {\n            var children = ele.children().intersection(eles);\n\n            //      let random = 0;\n            while (children.nodes(\":childless\").length == 0) {\n              //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n              children = children.nodes()[0].children().intersection(eles);\n            }\n            //  select the representative node - we can apply different methods here\n            //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n            var index = 0;\n            var min = children.nodes(\":childless\")[0].connectedEdges().length;\n            children.nodes(\":childless\").forEach(function (ele2, i) {\n              if (ele2.connectedEdges().length < min) {\n                min = ele2.connectedEdges().length;\n                index = i;\n              }\n            });\n            parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n          });\n\n          // add neighborhood relations (first real, then dummy nodes)\n          nodes.forEach(function (ele) {\n            var eleIndex = void 0;\n            if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n            ele.neighborhood().nodes().forEach(function (node) {\n              if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n              }\n            });\n          });\n          var _loop = function _loop(_key) {\n            var eleIndex = nodeIndexes.get(_key);\n            var disconnectedId = void 0;\n            dummyNodes.get(_key).forEach(function (id) {\n              if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n              allNodesNeighborhood[eleIndex].push(disconnectedId);\n              allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n            });\n          };\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n          try {\n            for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _key = _step2.value;\n              _loop(_key);\n            }\n\n            // nodeSize now only considers the size of transformed graph\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n          nodeSize = nodeIndexes.size;\n          var spectralResult = void 0;\n\n          // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n          // So skip spectral and layout the graph with cose\n          if (nodeSize > 2) {\n            // if # of nodes in transformed graph is smaller than sample size,\n            // then use # of nodes as sample size\n            sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n            // instantiates the partial matrices that will be used in spectral layout\n            for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n              C[_i14] = [];\n            }\n            for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n              INV[_i15] = [];\n            }\n\n            /**** Apply spectral layout ****/\n\n            if (options.quality == \"draft\" || options.step == \"all\") {\n              allBFS(samplingType);\n              sample();\n              powerIteration();\n              spectralResult = {\n                nodeIndexes: nodeIndexes,\n                xCoords: xCoords,\n                yCoords: yCoords\n              };\n            } else {\n              nodeIndexes.forEach(function (value, key) {\n                xCoords.push(cy.getElementById(key).position(\"x\"));\n                yCoords.push(cy.getElementById(key).position(\"y\"));\n              });\n              spectralResult = {\n                nodeIndexes: nodeIndexes,\n                xCoords: xCoords,\n                yCoords: yCoords\n              };\n            }\n            return spectralResult;\n          } else {\n            var iterator = nodeIndexes.keys();\n            var firstNode = cy.getElementById(iterator.next().value);\n            var firstNodePos = firstNode.position();\n            var firstNodeWidth = firstNode.outerWidth();\n            xCoords.push(firstNodePos.x);\n            yCoords.push(firstNodePos.y);\n            if (nodeSize == 2) {\n              var secondNode = cy.getElementById(iterator.next().value);\n              var secondNodeWidth = secondNode.outerWidth();\n              xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n              yCoords.push(firstNodePos.y);\n            }\n            spectralResult = {\n              nodeIndexes: nodeIndexes,\n              xCoords: xCoords,\n              yCoords: yCoords\n            };\n            return spectralResult;\n          }\n        };\n        module.exports = {\n          spectralLayout: spectralLayout\n        };\n\n        /***/\n      }),\n      /***/579: (/***/(module, __unused_webpack_exports, __webpack_require__) => {\n        var impl = __webpack_require__(212);\n\n        // registers the extension on a cytoscape lib ref\n        var register = function register(cytoscape) {\n          if (!cytoscape) {\n            return;\n          } // can't register if cytoscape unspecified\n\n          cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n        };\n        if (typeof cytoscape !== 'undefined') {\n          // expose to global cytoscape (i.e. window.cytoscape)\n          register(cytoscape);\n        }\n        module.exports = register;\n\n        /***/\n      }),\n      /***/281: (/***/module => {\n        module.exports = __WEBPACK_EXTERNAL_MODULE__281__;\n\n        /***/\n      })\n\n      /******/\n    };\n    /************************************************************************/\n    /******/ // The module cache\n    /******/\n    var __webpack_module_cache__ = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/ // Check if module is in cache\n      /******/var cachedModule = __webpack_module_cache__[moduleId];\n      /******/\n      if (cachedModule !== undefined) {\n        /******/return cachedModule.exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /************************************************************************/\n    /******/\n    /******/ // startup\n    /******/ // Load entry module and return exports\n    /******/ // This entry module is referenced by other modules so it can't be inlined\n    /******/\n    var __webpack_exports__ = __webpack_require__(579);\n    /******/\n    /******/\n    return __webpack_exports__;\n    /******/\n  })();\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__281__","__webpack_modules__","Object","assign","bind","tgt","_len","arguments","length","srcs","Array","_key","forEach","src","keys","k","__unused_webpack_exports","__webpack_require__","LinkedList","layoutBase","auxiliary","getTopMostNodes","nodes","nodesMap","i","id","roots","filter","ele","parent","connectComponents","cy","eles","topMostNodes","dummyNodes","queue","visited","Set","visitedTopMostNodes","currentNeighbor","minDegreeNode","minDegree","isConnected","count","nodesConnectedToDummy","components","_loop","cmpt","collection","push","currentNode","childrenOfCurrentNode","merge","descendants","intersection","node","add","_loop2","shift","neighborNodes","neighborhood","edgesWith","neighborNode","union","ancestors","has","childrenOfNeighbor","connectedEdges","e","source","target","temp","difference","set","size","calcBoundingBox","parentNode","xCoords","yCoords","nodeIndexes","left","Number","MAX_SAFE_INTEGER","right","MIN_SAFE_INTEGER","top","bottom","nodeLeft","nodeRight","nodeTop","nodeBottom","not","s","get","width","height","boundingBox","topLeftX","topLeftY","aux","CoSELayout","CoSENode","PointD","DimensionD","LayoutConstants","FDLayoutConstants","CoSEConstants","coseLayout","options","spectralResult","edges","idToLNode","randomize","isFn","fn","optFn","opt","processChildrenList","children","layout","theChild","children_of_children","theNode","dimensions","layoutDimensions","nodeDimensionsIncludeLabels","outerWidth","outerHeight","isParent","graphManager","w","h","parseFloat","parentInfo","position","data","nodeRepulsion","paddingLeft","parseInt","css","paddingTop","paddingRight","paddingBottom","labelWidth","includeLabels","includeNodes","includeOverlays","labelHeight","labelPosVertical","labelPosHorizontal","isNaN","rect","x","y","theNewGraph","getGraphManager","newGraph","processEdges","gm","idealLengthTotal","edgeCount","edge","sourceNode","targetNode","getEdgesBetween","e1","newEdge","idealLength","idealEdgeLength","edgeElasticity","DEFAULT_EDGE_LENGTH","MIN_REPULSION_DIST","DEFAULT_RADIAL_SEPARATION","processConstraints","fixedNodeConstraint","constraints","alignmentConstraint","relativePlacementConstraint","nestingFactor","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","gravity","DEFAULT_GRAVITY_STRENGTH","numIter","MAX_ITERATIONS","gravityRange","DEFAULT_GRAVITY_RANGE_FACTOR","gravityCompound","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeCompound","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","initialEnergyOnIncremental","DEFAULT_COOLING_FACTOR_INCREMENTAL","quality","QUALITY","NODE_DIMENSIONS_INCLUDE_LABELS","DEFAULT_INCREMENTAL","ANIMATE","animate","TILE","tile","TILING_PADDING_VERTICAL","tilingPaddingVertical","call","TILING_PADDING_HORIZONTAL","tilingPaddingHorizontal","PURE_INCREMENTAL","DEFAULT_UNIFORM_LEAF_NODE_SIZES","uniformNodeDimensions","step","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","TREE_REDUCTION_ON_INCREMENTAL","newGraphManager","addRoot","runLayout","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","_require","spectralLayout","_require2","defaults","freeze","animationDuration","animationEasing","undefined","fit","padding","packComponents","samplingType","sampleSize","nodeSeparation","piTol","ready","stop","Layout","value","run","coseResult","isArray","vertical","horizontal","constraintExist","layUtil","packingEnabled","layoutUtilities","result","component","toBeTiledNodes","Map","_xCoords","_yCoords","tempSpectralResult","indexesToBeDeleted","index","splice","subgraphs","subgraph","nodeIndex","boundingbox","getLeft","getTop","getWidth","getHeight","sourceNodeIndex","targetNodeIndex","sourceCenter","targetCenter","_parentInfo","startX","startY","endX","endY","getCenterX","getCenterY","shiftResult","shifts","newXCoords","map","dx","newYCoords","dy","item","nodeRectangle","setCenter","minXCoord","POSITIVE_INFINITY","maxXCoord","NEGATIVE_INFINITY","minYCoord","maxYCoord","diffOnX","x1","diffOnY","y1","_boundingBox","_diffOnX","_diffOnY","getPositions","pos","theId","getRect","_pos","layoutPositions","console","log","Matrix","SVD","parentNodes","parentChildMap","allNodesNeighborhood","samplesColumn","minDistancesColumn","C","PHI","INV","firstSample","nodeSize","infinity","small","randomSampleCR","sample","flag","Math","floor","random","BFS","pivot","samplingMethod","path","front","back","current","distance","max_dist","max_ind","neighbors","_i","_i2","_i3","allBFS","_i4","_i5","_i6","j","_i7","_i8","_j","SVDResult","svd","a_q","S","a_u","U","a_v","V","max_s","a_Sig","multMat","transpose","powerIteration","theta1","theta2","Y1","Y2","V1","V2","normalize","previous","_i9","multGamma","multL","dotProduct","abs","_i10","_i11","minusOp","multCons","_i12","sqrt","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","err","return","_i13","min","ele2","eleIndex","disconnectedId","getElementById","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_i14","_i15","firstNode","firstNodePos","firstNodeWidth","secondNode","secondNodeWidth","impl","register","cytoscape","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["/home/lbarbosa/Documents/Github/murabei-st-cytoscape/murabei_st_cytoscape/frontend/node_modules/cytoscape-fcose/cytoscape-fcose.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cose-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cose-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"));\n\telse\n\t\troot[\"cytoscapeFcose\"] = factory(root[\"coseBase\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__281__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __webpack_require__(281).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __webpack_require__(548);\nvar CoSELayout = __webpack_require__(281).CoSELayout;\nvar CoSENode = __webpack_require__(281).CoSENode;\nvar PointD = __webpack_require__(281).layoutBase.PointD;\nvar DimensionD = __webpack_require__(281).layoutBase.DimensionD;\nvar LayoutConstants = __webpack_require__(281).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __webpack_require__(281).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __webpack_require__(281).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = theChild.children();\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __webpack_require__(658);\nvar aux = __webpack_require__(548);\n\nvar _require = __webpack_require__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __webpack_require__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          if (options.randomize) {\n            var result = spectralLayout(options); // apply spectral layout        \n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n\n          //send each component to spectral layout\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n            });\n          }\n\n          // packing\n          if (components.length > 1) {\n            var subgraphs = [];\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n              var subgraph = {};\n              subgraph.nodes = [];\n              subgraph.edges = [];\n              var nodeIndex = void 0;\n              component.nodes().forEach(function (node) {\n                if (options.quality == \"draft\") {\n                  if (!node.isParent()) {\n                    nodeIndex = nodeIndexes.get(node.id());\n                    subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                  } else {\n                    var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                  }\n                } else {\n                  subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                }\n              });\n              component.edges().forEach(function (edge) {\n                var source = edge.source();\n                var target = edge.target();\n                if (options.quality == \"draft\") {\n                  var sourceNodeIndex = nodeIndexes.get(source.id());\n                  var targetNodeIndex = nodeIndexes.get(target.id());\n                  var sourceCenter = [];\n                  var targetCenter = [];\n                  if (source.isParent()) {\n                    var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                    sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                  } else {\n                    sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                    sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                  }\n                  if (target.isParent()) {\n                    var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                    targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                  } else {\n                    targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                    targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                  }\n                  subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                } else {\n                  subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                }\n              });\n              subgraphs.push(subgraph);\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              coseResult.forEach(function (result, index) {\n                Object.keys(result).forEach(function (item) {\n                  var nodeRectangle = result[item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[index].dx, nodeRectangle.getCenterY() + shiftResult[index].dy);\n                });\n              });\n            }\n          }\n        }\n\n        // move graph to its original position because spectral moves it to origin\n        if (options.randomize && !options.fixedNodeConstraint) {\n          var minXCoord = Number.POSITIVE_INFINITY;\n          var maxXCoord = Number.NEGATIVE_INFINITY;\n          var minYCoord = Number.POSITIVE_INFINITY;\n          var maxYCoord = Number.NEGATIVE_INFINITY;\n          if (options.quality == \"draft\") {\n            spectralResult.forEach(function (result) {\n              result.xCoords.forEach(function (value) {\n                if (value < minXCoord) minXCoord = value;\n                if (value > maxXCoord) maxXCoord = value;\n              });\n              result.yCoords.forEach(function (value) {\n                if (value < minYCoord) minYCoord = value;\n                if (value > maxYCoord) maxYCoord = value;\n              });\n            });\n            var boundingBox = options.eles.boundingBox();\n            var diffOnX = boundingBox.x1 + boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;\n            var diffOnY = boundingBox.y1 + boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;\n            spectralResult.forEach(function (result) {\n              result.xCoords = result.xCoords.map(function (x) {\n                return x + diffOnX;\n              });\n              result.yCoords = result.yCoords.map(function (y) {\n                return y + diffOnY;\n              });\n            });\n          } else {\n            coseResult.forEach(function (result) {\n              Object.keys(result).forEach(function (item) {\n                var node = result[item];\n                if (node.getCenterX() < minXCoord) minXCoord = node.getCenterX();\n                if (node.getCenterX() > maxXCoord) maxXCoord = node.getCenterX();\n                if (node.getCenterY() < minYCoord) minYCoord = node.getCenterY();\n                if (node.getCenterY() > maxYCoord) maxYCoord = node.getCenterY();\n              });\n            });\n            var _boundingBox = options.eles.boundingBox();\n            var _diffOnX = _boundingBox.x1 + _boundingBox.w / 2 - (maxXCoord + minXCoord) / 2;\n            var _diffOnY = _boundingBox.y1 + _boundingBox.h / 2 - (maxYCoord + minYCoord) / 2;\n            coseResult.forEach(function (result, index) {\n              Object.keys(result).forEach(function (item) {\n                var node = result[item];\n                node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n              });\n            });\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        options.eles = eles;\n        eles.nodes().not(\":parent\").layoutPositions(layout, options, getPositions);\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __webpack_require__(548);\nvar Matrix = __webpack_require__(281).layoutBase.Matrix;\nvar SVD = __webpack_require__(281).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\n\nvar impl = __webpack_require__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 281:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__281__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(579);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) {\n        /******/return installedModules[moduleId].exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/i: moduleId,\n        /******/l: false,\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Flag the module as loaded\n      /******/\n      module.l = true;\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // identity function for calling harmony imports with the correct context\n    /******/\n    __webpack_require__.i = function (value) {\n      return value;\n    };\n    /******/\n    /******/ // define getter function for harmony exports\n    /******/\n    __webpack_require__.d = function (exports, name, getter) {\n      /******/if (!__webpack_require__.o(exports, name)) {\n        /******/Object.defineProperty(exports, name, {\n          /******/configurable: false,\n          /******/enumerable: true,\n          /******/get: getter\n          /******/\n        });\n        /******/\n      }\n      /******/\n    };\n    /******/\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/\n    __webpack_require__.n = function (module) {\n      /******/var getter = module && module.__esModule ? /******/function getDefault() {\n        return module['default'];\n      } : /******/function getModuleExports() {\n        return module;\n      };\n      /******/\n      __webpack_require__.d(getter, 'a', getter);\n      /******/\n      return getter;\n      /******/\n    };\n    /******/\n    /******/ // Object.prototype.hasOwnProperty.call\n    /******/\n    __webpack_require__.o = function (object, property) {\n      return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(__webpack_require__.s = 8);\n    /******/\n  }\n  /************************************************************************/\n  /******/([(/* 0 */\n  /***/function (module, exports) {\n    module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n    /***/\n  }), (/* 1 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n    function CoSEConstants() {}\n\n    //CoSEConstants inherits static props in FDLayoutConstants\n    for (var prop in FDLayoutConstants) {\n      CoSEConstants[prop] = FDLayoutConstants[prop];\n    }\n    CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n    CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n    CoSEConstants.TILE = true;\n    CoSEConstants.TILING_PADDING_VERTICAL = 10;\n    CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n    CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n    // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n    // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\n    CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n    module.exports = CoSEConstants;\n\n    /***/\n  }), (/* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n    function CoSEEdge(source, target, vEdge) {\n      FDLayoutEdge.call(this, source, target, vEdge);\n    }\n    CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n    for (var prop in FDLayoutEdge) {\n      CoSEEdge[prop] = FDLayoutEdge[prop];\n    }\n    module.exports = CoSEEdge;\n\n    /***/\n  }), (/* 3 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var LGraph = __webpack_require__(0).LGraph;\n    function CoSEGraph(parent, graphMgr, vGraph) {\n      LGraph.call(this, parent, graphMgr, vGraph);\n    }\n    CoSEGraph.prototype = Object.create(LGraph.prototype);\n    for (var prop in LGraph) {\n      CoSEGraph[prop] = LGraph[prop];\n    }\n    module.exports = CoSEGraph;\n\n    /***/\n  }), (/* 4 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var LGraphManager = __webpack_require__(0).LGraphManager;\n    function CoSEGraphManager(layout) {\n      LGraphManager.call(this, layout);\n    }\n    CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n    for (var prop in LGraphManager) {\n      CoSEGraphManager[prop] = LGraphManager[prop];\n    }\n    module.exports = CoSEGraphManager;\n\n    /***/\n  }), (/* 5 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayoutNode = __webpack_require__(0).FDLayoutNode;\n    var IMath = __webpack_require__(0).IMath;\n    function CoSENode(gm, loc, size, vNode) {\n      FDLayoutNode.call(this, gm, loc, size, vNode);\n    }\n    CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n    for (var prop in FDLayoutNode) {\n      CoSENode[prop] = FDLayoutNode[prop];\n    }\n    CoSENode.prototype.calculateDisplacement = function () {\n      var layout = this.graphManager.getLayout();\n      // this check is for compound nodes that contain fixed nodes\n      if (this.getChild() != null && this.fixedNodeWeight) {\n        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n      } else {\n        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n      }\n      if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n        this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n      }\n      if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n        this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n      }\n\n      // non-empty compound node, propogate movement to children as well\n      if (this.child && this.child.getNodes().length > 0) {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n    };\n    CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n      var nodes = this.getChild().getNodes();\n      var node;\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        if (node.getChild() == null) {\n          node.displacementX += dX;\n          node.displacementY += dY;\n        } else {\n          node.propogateDisplacementToChildren(dX, dY);\n        }\n      }\n    };\n    CoSENode.prototype.move = function () {\n      var layout = this.graphManager.getLayout();\n\n      // a simple node or an empty compound node, move it\n      if (this.child == null || this.child.getNodes().length == 0) {\n        this.moveBy(this.displacementX, this.displacementY);\n        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n      }\n      this.springForceX = 0;\n      this.springForceY = 0;\n      this.repulsionForceX = 0;\n      this.repulsionForceY = 0;\n      this.gravitationForceX = 0;\n      this.gravitationForceY = 0;\n      this.displacementX = 0;\n      this.displacementY = 0;\n    };\n    CoSENode.prototype.setPred1 = function (pred1) {\n      this.pred1 = pred1;\n    };\n    CoSENode.prototype.getPred1 = function () {\n      return pred1;\n    };\n    CoSENode.prototype.getPred2 = function () {\n      return pred2;\n    };\n    CoSENode.prototype.setNext = function (next) {\n      this.next = next;\n    };\n    CoSENode.prototype.getNext = function () {\n      return next;\n    };\n    CoSENode.prototype.setProcessed = function (processed) {\n      this.processed = processed;\n    };\n    CoSENode.prototype.isProcessed = function () {\n      return processed;\n    };\n    module.exports = CoSENode;\n\n    /***/\n  }), (/* 6 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function _toConsumableArray(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n          arr2[i] = arr[i];\n        }\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    }\n    var CoSEConstants = __webpack_require__(1);\n    var LinkedList = __webpack_require__(0).LinkedList;\n    var Matrix = __webpack_require__(0).Matrix;\n    var SVD = __webpack_require__(0).SVD;\n    function ConstraintHandler() {}\n    ConstraintHandler.handleConstraints = function (layout) {\n      //  let layout = this.graphManager.getLayout();\n\n      // get constraints from layout\n      var constraints = {};\n      constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n      constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n      constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n      var idToNodeMap = new Map();\n      var nodeIndexes = new Map();\n      var xCoords = [];\n      var yCoords = [];\n      var allNodes = layout.getAllNodes();\n      var index = 0;\n      // fill index map and coordinates\n      for (var i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n        if (node.getChild() == null) {\n          nodeIndexes.set(node.id, index++);\n          xCoords.push(node.getCenterX());\n          yCoords.push(node.getCenterY());\n          idToNodeMap.set(node.id, node);\n        }\n      }\n\n      // if there exists relative placement constraint without gap value, set it to default \n      if (constraints.relativePlacementConstraint) {\n        constraints.relativePlacementConstraint.forEach(function (constraint) {\n          if (!constraint.gap && constraint.gap != 0) {\n            if (constraint.left) {\n              constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n            } else {\n              constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n            }\n          }\n        });\n      }\n\n      /* auxiliary functions */\n\n      // calculate difference between two position objects\n      var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n        return {\n          x: pos1.x - pos2.x,\n          y: pos1.y - pos2.y\n        };\n      };\n\n      // calculate average position of the nodes\n      var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n        var xPosSum = 0;\n        var yPosSum = 0;\n        nodeIdSet.forEach(function (nodeId) {\n          xPosSum += xCoords[nodeIndexes.get(nodeId)];\n          yPosSum += yCoords[nodeIndexes.get(nodeId)];\n        });\n        return {\n          x: xPosSum / nodeIdSet.size,\n          y: yPosSum / nodeIdSet.size\n        };\n      };\n\n      // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n      // this function also takes the fixed nodes and alignment constraints into account\n      // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n      // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n      var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n        // find union of two sets\n        function setUnion(setA, setB) {\n          var union = new Set(setA);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n          try {\n            for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var elem = _step.value;\n              union.add(elem);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          return union;\n        }\n\n        // find indegree count for each node\n        var inDegrees = new Map();\n        graph.forEach(function (value, key) {\n          inDegrees.set(key, 0);\n        });\n        graph.forEach(function (value, key) {\n          value.forEach(function (adjacent) {\n            inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n          });\n        });\n        var positionMap = new Map(); // keeps the position for each node\n        var pastMap = new Map(); // keeps the predecessors(past) of a node\n        var queue = new LinkedList();\n        inDegrees.forEach(function (value, key) {\n          if (value == 0) {\n            queue.push(key);\n            if (!fixedNodes) {\n              if (direction == \"horizontal\") {\n                positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n              } else {\n                positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n              }\n            }\n          } else {\n            positionMap.set(key, Number.NEGATIVE_INFINITY);\n          }\n          if (fixedNodes) {\n            pastMap.set(key, new Set([key]));\n          }\n        });\n\n        // align sources of each component in enforcement phase\n        if (fixedNodes) {\n          componentSources.forEach(function (component) {\n            var fixedIds = [];\n            component.forEach(function (nodeId) {\n              if (fixedNodes.has(nodeId)) {\n                fixedIds.push(nodeId);\n              }\n            });\n            if (fixedIds.length > 0) {\n              var position = 0;\n              fixedIds.forEach(function (fixedId) {\n                if (direction == \"horizontal\") {\n                  positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                  position += positionMap.get(fixedId);\n                } else {\n                  positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                  position += positionMap.get(fixedId);\n                }\n              });\n              position = position / fixedIds.length;\n              component.forEach(function (nodeId) {\n                if (!fixedNodes.has(nodeId)) {\n                  positionMap.set(nodeId, position);\n                }\n              });\n            } else {\n              var _position = 0;\n              component.forEach(function (nodeId) {\n                if (direction == \"horizontal\") {\n                  _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                } else {\n                  _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                }\n              });\n              _position = _position / component.length;\n              component.forEach(function (nodeId) {\n                positionMap.set(nodeId, _position);\n              });\n            }\n          });\n        }\n\n        // calculate positions of the nodes\n\n        var _loop = function _loop() {\n          var currentNode = queue.shift();\n          var neighbors = graph.get(currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n              if (fixedNodes && fixedNodes.has(neighbor.id)) {\n                var fixedPosition = void 0;\n                if (direction == \"horizontal\") {\n                  fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                } else {\n                  fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                }\n                positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n                if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                  var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                  pastMap.get(currentNode).forEach(function (nodeId) {\n                    positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                  });\n                }\n              } else {\n                positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n              }\n            }\n            inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n            if (inDegrees.get(neighbor.id) == 0) {\n              queue.push(neighbor.id);\n            }\n            if (fixedNodes) {\n              pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n            }\n          });\n        };\n        while (queue.length != 0) {\n          _loop();\n        }\n\n        // readjust position of the nodes after enforcement\n        if (fixedNodes) {\n          // find indegree count for each node\n          var sinkNodes = new Set();\n          graph.forEach(function (value, key) {\n            if (value.length == 0) {\n              sinkNodes.add(key);\n            }\n          });\n          var _components = [];\n          pastMap.forEach(function (value, key) {\n            if (sinkNodes.has(key)) {\n              var isFixedComponent = false;\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n              try {\n                for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var nodeId = _step2.value;\n                  if (fixedNodes.has(nodeId)) {\n                    isFixedComponent = true;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n              if (!isFixedComponent) {\n                var isExist = false;\n                var existAt = void 0;\n                _components.forEach(function (component, index) {\n                  if (component.has([].concat(_toConsumableArray(value))[0])) {\n                    isExist = true;\n                    existAt = index;\n                  }\n                });\n                if (!isExist) {\n                  _components.push(new Set(value));\n                } else {\n                  value.forEach(function (ele) {\n                    _components[existAt].add(ele);\n                  });\n                }\n              }\n            }\n          });\n          _components.forEach(function (component, index) {\n            var minBefore = Number.POSITIVE_INFINITY;\n            var minAfter = Number.POSITIVE_INFINITY;\n            var maxBefore = Number.NEGATIVE_INFINITY;\n            var maxAfter = Number.NEGATIVE_INFINITY;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n              for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var nodeId = _step3.value;\n                var posBefore = void 0;\n                if (direction == \"horizontal\") {\n                  posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                } else {\n                  posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                }\n                var posAfter = positionMap.get(nodeId);\n                if (posBefore < minBefore) {\n                  minBefore = posBefore;\n                }\n                if (posBefore > maxBefore) {\n                  maxBefore = posBefore;\n                }\n                if (posAfter < minAfter) {\n                  minAfter = posAfter;\n                }\n                if (posAfter > maxAfter) {\n                  maxAfter = posAfter;\n                }\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n            var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n            try {\n              for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var _nodeId = _step4.value;\n                positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n          });\n        }\n        return positionMap;\n      };\n\n      // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n      // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n      var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n        // variables to count votes\n        var reflectOnY = 0,\n          notReflectOnY = 0;\n        var reflectOnX = 0,\n          notReflectOnX = 0;\n        relativePlacementConstraints.forEach(function (constraint) {\n          if (constraint.left) {\n            xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n          } else {\n            yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n          }\n        });\n        if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n          for (var _i = 0; _i < nodeIndexes.size; _i++) {\n            xCoords[_i] = -1 * xCoords[_i];\n            yCoords[_i] = -1 * yCoords[_i];\n          }\n        } else if (reflectOnY > notReflectOnY) {\n          for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n            xCoords[_i2] = -1 * xCoords[_i2];\n          }\n        } else if (reflectOnX > notReflectOnX) {\n          for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n            yCoords[_i3] = -1 * yCoords[_i3];\n          }\n        }\n      };\n\n      // find weakly connected components in undirected graph\n      var findComponents = function findComponents(graph) {\n        // find weakly connected components in dag\n        var components = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            var _currentNode = key;\n            queue.push(_currentNode);\n            visited.add(_currentNode);\n            components[count].push(_currentNode);\n            while (queue.length != 0) {\n              _currentNode = queue.shift();\n              var neighbors = graph.get(_currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor.id)) {\n                  queue.push(neighbor.id);\n                  visited.add(neighbor.id);\n                  components[count].push(neighbor.id);\n                }\n              });\n            }\n            count++;\n          }\n        });\n        return components;\n      };\n\n      // return undirected version of given dag\n      var dagToUndirected = function dagToUndirected(dag) {\n        var undirected = new Map();\n        dag.forEach(function (value, key) {\n          undirected.set(key, []);\n        });\n        dag.forEach(function (value, key) {\n          value.forEach(function (adjacent) {\n            undirected.get(key).push(adjacent);\n            undirected.get(adjacent.id).push({\n              id: key,\n              gap: adjacent.gap,\n              direction: adjacent.direction\n            });\n          });\n        });\n        return undirected;\n      };\n\n      // return reversed (directions inverted) version of given dag\n      var dagToReversed = function dagToReversed(dag) {\n        var reversed = new Map();\n        dag.forEach(function (value, key) {\n          reversed.set(key, []);\n        });\n        dag.forEach(function (value, key) {\n          value.forEach(function (adjacent) {\n            reversed.get(adjacent.id).push({\n              id: key,\n              gap: adjacent.gap,\n              direction: adjacent.direction\n            });\n          });\n        });\n        return reversed;\n      };\n\n      /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n      // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n      // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n      /* construct source and target configurations */\n\n      var targetMatrix = []; // A - target configuration\n      var sourceMatrix = []; // B - source configuration \n      var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n      var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n      var fixedNodes = new Set();\n      var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n      var dagUndirected = new Map(); // undirected version of the dag\n      var components = []; // weakly connected components\n\n      // fill fixedNodes collection to use later\n      if (constraints.fixedNodeConstraint) {\n        constraints.fixedNodeConstraint.forEach(function (nodeData) {\n          fixedNodes.add(nodeData.nodeId);\n        });\n      }\n\n      // construct dag from relative placement constraints \n      if (constraints.relativePlacementConstraint) {\n        // construct both directed and undirected version of the dag\n        constraints.relativePlacementConstraint.forEach(function (constraint) {\n          if (constraint.left) {\n            if (dag.has(constraint.left)) {\n              dag.get(constraint.left).push({\n                id: constraint.right,\n                gap: constraint.gap,\n                direction: \"horizontal\"\n              });\n            } else {\n              dag.set(constraint.left, [{\n                id: constraint.right,\n                gap: constraint.gap,\n                direction: \"horizontal\"\n              }]);\n            }\n            if (!dag.has(constraint.right)) {\n              dag.set(constraint.right, []);\n            }\n          } else {\n            if (dag.has(constraint.top)) {\n              dag.get(constraint.top).push({\n                id: constraint.bottom,\n                gap: constraint.gap,\n                direction: \"vertical\"\n              });\n            } else {\n              dag.set(constraint.top, [{\n                id: constraint.bottom,\n                gap: constraint.gap,\n                direction: \"vertical\"\n              }]);\n            }\n            if (!dag.has(constraint.bottom)) {\n              dag.set(constraint.bottom, []);\n            }\n          }\n        });\n        dagUndirected = dagToUndirected(dag);\n        components = findComponents(dagUndirected);\n      }\n      if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n        // first check fixed node constraint\n        if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n          constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n            targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n            sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n          });\n          standardTransformation = true;\n        } else if (constraints.alignmentConstraint) {\n          (function () {\n            // then check alignment constraint\n            var count = 0;\n            if (constraints.alignmentConstraint.vertical) {\n              var verticalAlign = constraints.alignmentConstraint.vertical;\n              var _loop2 = function _loop2(_i4) {\n                var alignmentSet = new Set();\n                verticalAlign[_i4].forEach(function (nodeId) {\n                  alignmentSet.add(nodeId);\n                });\n                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                  return fixedNodes.has(x);\n                }));\n                var xPos = void 0;\n                if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n                verticalAlign[_i4].forEach(function (nodeId) {\n                  targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n                  sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                  count++;\n                });\n              };\n              for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n                _loop2(_i4);\n              }\n              standardTransformation = true;\n            }\n            if (constraints.alignmentConstraint.horizontal) {\n              var horizontalAlign = constraints.alignmentConstraint.horizontal;\n              var _loop3 = function _loop3(_i5) {\n                var alignmentSet = new Set();\n                horizontalAlign[_i5].forEach(function (nodeId) {\n                  alignmentSet.add(nodeId);\n                });\n                var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                  return fixedNodes.has(x);\n                }));\n                var yPos = void 0;\n                if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n                horizontalAlign[_i5].forEach(function (nodeId) {\n                  targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n                  sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n                  count++;\n                });\n              };\n              for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n                _loop3(_i5);\n              }\n              standardTransformation = true;\n            }\n            if (constraints.relativePlacementConstraint) {\n              reflectionType = true;\n            }\n          })();\n        } else if (constraints.relativePlacementConstraint) {\n          // finally check relative placement constraint\n          // find largest component in dag\n          var largestComponentSize = 0;\n          var largestComponentIndex = 0;\n          for (var _i6 = 0; _i6 < components.length; _i6++) {\n            if (components[_i6].length > largestComponentSize) {\n              largestComponentSize = components[_i6].length;\n              largestComponentIndex = _i6;\n            }\n          }\n          // if largest component isn't dominant, then take the votes for reflection\n          if (largestComponentSize < dagUndirected.size / 2) {\n            applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n            standardTransformation = false;\n            reflectionType = false;\n          } else {\n            // use largest component for transformation\n            // construct horizontal and vertical subgraphs in the largest component\n            var subGraphOnHorizontal = new Map();\n            var subGraphOnVertical = new Map();\n            var constraintsInlargestComponent = [];\n            components[largestComponentIndex].forEach(function (nodeId) {\n              dag.get(nodeId).forEach(function (adjacent) {\n                if (adjacent.direction == \"horizontal\") {\n                  if (subGraphOnHorizontal.has(nodeId)) {\n                    subGraphOnHorizontal.get(nodeId).push(adjacent);\n                  } else {\n                    subGraphOnHorizontal.set(nodeId, [adjacent]);\n                  }\n                  if (!subGraphOnHorizontal.has(adjacent.id)) {\n                    subGraphOnHorizontal.set(adjacent.id, []);\n                  }\n                  constraintsInlargestComponent.push({\n                    left: nodeId,\n                    right: adjacent.id\n                  });\n                } else {\n                  if (subGraphOnVertical.has(nodeId)) {\n                    subGraphOnVertical.get(nodeId).push(adjacent);\n                  } else {\n                    subGraphOnVertical.set(nodeId, [adjacent]);\n                  }\n                  if (!subGraphOnVertical.has(adjacent.id)) {\n                    subGraphOnVertical.set(adjacent.id, []);\n                  }\n                  constraintsInlargestComponent.push({\n                    top: nodeId,\n                    bottom: adjacent.id\n                  });\n                }\n              });\n            });\n            applyReflectionForRelativePlacement(constraintsInlargestComponent);\n            reflectionType = false;\n\n            // calculate appropriate positioning for subgraphs\n            var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n            var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n            // construct source and target configuration\n            components[largestComponentIndex].forEach(function (nodeId, i) {\n              sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              targetMatrix[i] = [];\n              if (positionMapHorizontal.has(nodeId)) {\n                targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n              } else {\n                targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n              }\n              if (positionMapVertical.has(nodeId)) {\n                targetMatrix[i][1] = positionMapVertical.get(nodeId);\n              } else {\n                targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n              }\n            });\n            standardTransformation = true;\n          }\n        }\n\n        // if transformation is required, then calculate and apply transformation matrix\n        if (standardTransformation) {\n          /* calculate transformation matrix */\n          var transformationMatrix = void 0;\n          var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n          var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n          // centralize transpose matrices\n          for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n            targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n            sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n          }\n\n          // do actual calculation for transformation matrix\n          var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n          var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n          transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n          /* apply found transformation matrix to obtain final draft layout */\n          for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n            var temp1 = [xCoords[_i8], yCoords[_i8]];\n            var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n            var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n            xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n            yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n          }\n\n          // applied only both alignment and rel. placement constraints exist\n          if (reflectionType) {\n            applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n          }\n        }\n      }\n      if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n        /****  enforce constraints on the transformed draft layout ****/\n\n        /* first enforce fixed node constraint */\n\n        if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n          var translationAmount = {\n            x: 0,\n            y: 0\n          };\n          constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n            var posInTheory = {\n              x: xCoords[nodeIndexes.get(nodeData.nodeId)],\n              y: yCoords[nodeIndexes.get(nodeData.nodeId)]\n            };\n            var posDesired = nodeData.position;\n            var posDiff = calculatePositionDiff(posDesired, posInTheory);\n            translationAmount.x += posDiff.x;\n            translationAmount.y += posDiff.y;\n          });\n          translationAmount.x /= constraints.fixedNodeConstraint.length;\n          translationAmount.y /= constraints.fixedNodeConstraint.length;\n          xCoords.forEach(function (value, i) {\n            xCoords[i] += translationAmount.x;\n          });\n          yCoords.forEach(function (value, i) {\n            yCoords[i] += translationAmount.y;\n          });\n          constraints.fixedNodeConstraint.forEach(function (nodeData) {\n            xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n            yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n          });\n        }\n\n        /* then enforce alignment constraint */\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var xAlign = constraints.alignmentConstraint.vertical;\n            var _loop4 = function _loop4(_i9) {\n              var alignmentSet = new Set();\n              xAlign[_i9].forEach(function (nodeId) {\n                alignmentSet.add(nodeId);\n              });\n              var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                return fixedNodes.has(x);\n              }));\n              var xPos = void 0;\n              if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n              alignmentSet.forEach(function (nodeId) {\n                if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n              });\n            };\n            for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n              _loop4(_i9);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var yAlign = constraints.alignmentConstraint.horizontal;\n            var _loop5 = function _loop5(_i10) {\n              var alignmentSet = new Set();\n              yAlign[_i10].forEach(function (nodeId) {\n                alignmentSet.add(nodeId);\n              });\n              var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n                return fixedNodes.has(x);\n              }));\n              var yPos = void 0;\n              if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n              alignmentSet.forEach(function (nodeId) {\n                if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n              });\n            };\n            for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n              _loop5(_i10);\n            }\n          }\n        }\n\n        /* finally enforce relative placement constraint */\n\n        if (constraints.relativePlacementConstraint) {\n          (function () {\n            var nodeToDummyForVerticalAlignment = new Map();\n            var nodeToDummyForHorizontalAlignment = new Map();\n            var dummyToNodeForVerticalAlignment = new Map();\n            var dummyToNodeForHorizontalAlignment = new Map();\n            var dummyPositionsForVerticalAlignment = new Map();\n            var dummyPositionsForHorizontalAlignment = new Map();\n            var fixedNodesOnHorizontal = new Set();\n            var fixedNodesOnVertical = new Set();\n\n            // fill maps and sets      \n            fixedNodes.forEach(function (nodeId) {\n              fixedNodesOnHorizontal.add(nodeId);\n              fixedNodesOnVertical.add(nodeId);\n            });\n            if (constraints.alignmentConstraint) {\n              if (constraints.alignmentConstraint.vertical) {\n                var verticalAlignment = constraints.alignmentConstraint.vertical;\n                var _loop6 = function _loop6(_i11) {\n                  dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n                  verticalAlignment[_i11].forEach(function (nodeId) {\n                    nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                    dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                    if (fixedNodes.has(nodeId)) {\n                      fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                    }\n                  });\n                  dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n                };\n                for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n                  _loop6(_i11);\n                }\n              }\n              if (constraints.alignmentConstraint.horizontal) {\n                var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                var _loop7 = function _loop7(_i12) {\n                  dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n                  horizontalAlignment[_i12].forEach(function (nodeId) {\n                    nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                    dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                    if (fixedNodes.has(nodeId)) {\n                      fixedNodesOnVertical.add(\"dummy\" + _i12);\n                    }\n                  });\n                  dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n                };\n                for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n                  _loop7(_i12);\n                }\n              }\n            }\n\n            // construct horizontal and vertical dags (subgraphs) from overall dag\n            var dagOnHorizontal = new Map();\n            var dagOnVertical = new Map();\n            var _loop8 = function _loop8(nodeId) {\n              dag.get(nodeId).forEach(function (adjacent) {\n                var sourceId = void 0;\n                var targetNode = void 0;\n                if (adjacent[\"direction\"] == \"horizontal\") {\n                  sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n                  if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                    targetNode = {\n                      id: nodeToDummyForVerticalAlignment.get(adjacent.id),\n                      gap: adjacent.gap,\n                      direction: adjacent.direction\n                    };\n                  } else {\n                    targetNode = adjacent;\n                  }\n                  if (dagOnHorizontal.has(sourceId)) {\n                    dagOnHorizontal.get(sourceId).push(targetNode);\n                  } else {\n                    dagOnHorizontal.set(sourceId, [targetNode]);\n                  }\n                  if (!dagOnHorizontal.has(targetNode.id)) {\n                    dagOnHorizontal.set(targetNode.id, []);\n                  }\n                } else {\n                  sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n                  if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                    targetNode = {\n                      id: nodeToDummyForHorizontalAlignment.get(adjacent.id),\n                      gap: adjacent.gap,\n                      direction: adjacent.direction\n                    };\n                  } else {\n                    targetNode = adjacent;\n                  }\n                  if (dagOnVertical.has(sourceId)) {\n                    dagOnVertical.get(sourceId).push(targetNode);\n                  } else {\n                    dagOnVertical.set(sourceId, [targetNode]);\n                  }\n                  if (!dagOnVertical.has(targetNode.id)) {\n                    dagOnVertical.set(targetNode.id, []);\n                  }\n                }\n              });\n            };\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n            try {\n              for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var nodeId = _step5.value;\n                _loop8(nodeId);\n              }\n\n              // find source nodes of each component in horizontal and vertical dags\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n            var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n            var undirectedOnVertical = dagToUndirected(dagOnVertical);\n            var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n            var componentsOnVertical = findComponents(undirectedOnVertical);\n            var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n            var reversedDagOnVertical = dagToReversed(dagOnVertical);\n            var componentSourcesOnHorizontal = [];\n            var componentSourcesOnVertical = [];\n            componentsOnHorizontal.forEach(function (component, index) {\n              componentSourcesOnHorizontal[index] = [];\n              component.forEach(function (nodeId) {\n                if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n                  componentSourcesOnHorizontal[index].push(nodeId);\n                }\n              });\n            });\n            componentsOnVertical.forEach(function (component, index) {\n              componentSourcesOnVertical[index] = [];\n              component.forEach(function (nodeId) {\n                if (reversedDagOnVertical.get(nodeId).length == 0) {\n                  componentSourcesOnVertical[index].push(nodeId);\n                }\n              });\n            });\n\n            // calculate appropriate positioning for subgraphs\n            var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n            var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n            // update positions of the nodes based on relative placement constraints\n\n            var _loop9 = function _loop9(key) {\n              if (dummyToNodeForVerticalAlignment.get(key)) {\n                dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n                  xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n                });\n              } else {\n                xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n              }\n            };\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n            try {\n              for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var key = _step6.value;\n                _loop9(key);\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                  _iterator6.return();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n            var _loop10 = function _loop10(key) {\n              if (dummyToNodeForHorizontalAlignment.get(key)) {\n                dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n                  yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n                });\n              } else {\n                yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n              }\n            };\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n            try {\n              for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var key = _step7.value;\n                _loop10(key);\n              }\n            } catch (err) {\n              _didIteratorError7 = true;\n              _iteratorError7 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                  _iterator7.return();\n                }\n              } finally {\n                if (_didIteratorError7) {\n                  throw _iteratorError7;\n                }\n              }\n            }\n          })();\n        }\n      }\n\n      // assign new coordinates to nodes after constraint handling\n      for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n        var _node = allNodes[_i13];\n        if (_node.getChild() == null) {\n          _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n        }\n      }\n    };\n    module.exports = ConstraintHandler;\n\n    /***/\n  }), (/* 7 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var FDLayout = __webpack_require__(0).FDLayout;\n    var CoSEGraphManager = __webpack_require__(4);\n    var CoSEGraph = __webpack_require__(3);\n    var CoSENode = __webpack_require__(5);\n    var CoSEEdge = __webpack_require__(2);\n    var CoSEConstants = __webpack_require__(1);\n    var ConstraintHandler = __webpack_require__(6);\n    var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n    var LayoutConstants = __webpack_require__(0).LayoutConstants;\n    var Point = __webpack_require__(0).Point;\n    var PointD = __webpack_require__(0).PointD;\n    var DimensionD = __webpack_require__(0).DimensionD;\n    var Layout = __webpack_require__(0).Layout;\n    var Integer = __webpack_require__(0).Integer;\n    var IGeometry = __webpack_require__(0).IGeometry;\n    var LGraph = __webpack_require__(0).LGraph;\n    var Transform = __webpack_require__(0).Transform;\n    var LinkedList = __webpack_require__(0).LinkedList;\n    function CoSELayout() {\n      FDLayout.call(this);\n      this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n      this.constraints = {}; // keep layout constraints\n    }\n    CoSELayout.prototype = Object.create(FDLayout.prototype);\n    for (var prop in FDLayout) {\n      CoSELayout[prop] = FDLayout[prop];\n    }\n    CoSELayout.prototype.newGraphManager = function () {\n      var gm = new CoSEGraphManager(this);\n      this.graphManager = gm;\n      return gm;\n    };\n    CoSELayout.prototype.newGraph = function (vGraph) {\n      return new CoSEGraph(null, this.graphManager, vGraph);\n    };\n    CoSELayout.prototype.newNode = function (vNode) {\n      return new CoSENode(this.graphManager, vNode);\n    };\n    CoSELayout.prototype.newEdge = function (vEdge) {\n      return new CoSEEdge(null, null, vEdge);\n    };\n    CoSELayout.prototype.initParameters = function () {\n      FDLayout.prototype.initParameters.call(this, arguments);\n      if (!this.isSubLayout) {\n        if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n          this.idealEdgeLength = 10;\n        } else {\n          this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n        }\n        this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n        // variables for tree reduction support\n        this.prunedNodesAll = [];\n        this.growTreeIterations = 0;\n        this.afterGrowthIterations = 0;\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = false;\n      }\n    };\n\n    // This method is used to set CoSE related parameters used by spring embedder.\n    CoSELayout.prototype.initSpringEmbedder = function () {\n      FDLayout.prototype.initSpringEmbedder.call(this);\n\n      // variables for cooling\n      this.coolingCycle = 0;\n      this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n      this.finalTemperature = 0.04;\n      this.coolingAdjuster = 1;\n    };\n    CoSELayout.prototype.layout = function () {\n      var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n      if (createBendsAsNeeded) {\n        this.createBendpoints();\n        this.graphManager.resetAllEdges();\n      }\n      this.level = 0;\n      return this.classicLayout();\n    };\n    CoSELayout.prototype.classicLayout = function () {\n      this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n      this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n      this.calcNoOfChildrenForAllNodes();\n      this.graphManager.calcLowestCommonAncestors();\n      this.graphManager.calcInclusionTreeDepths();\n      this.graphManager.getRoot().calcEstimatedSize();\n      this.calcIdealEdgeLengths();\n      if (!this.incremental) {\n        var forest = this.getFlatForest();\n\n        // The graph associated with this layout is flat and a forest\n        if (forest.length > 0) {\n          this.positionNodesRadially(forest);\n        }\n        // The graph associated with this layout is not flat or a forest\n        else {\n          // Reduce the trees when incremental mode is not enabled and graph is not a forest \n          this.reduceTrees();\n          // Update nodes that gravity will be applied\n          this.graphManager.resetAllNodesToApplyGravitation();\n          var allNodes = new Set(this.getAllNodes());\n          var intersection = this.nodesWithGravity.filter(function (x) {\n            return allNodes.has(x);\n          });\n          this.graphManager.setAllNodesToApplyGravitation(intersection);\n          this.positionNodesRandomly();\n        }\n      } else {\n        if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n          // Reduce the trees in incremental mode if only this constant is set to true \n          this.reduceTrees();\n          // Update nodes that gravity will be applied\n          this.graphManager.resetAllNodesToApplyGravitation();\n          var allNodes = new Set(this.getAllNodes());\n          var intersection = this.nodesWithGravity.filter(function (x) {\n            return allNodes.has(x);\n          });\n          this.graphManager.setAllNodesToApplyGravitation(intersection);\n        }\n      }\n      if (Object.keys(this.constraints).length > 0) {\n        ConstraintHandler.handleConstraints(this);\n        this.initConstraintVariables();\n      }\n      this.initSpringEmbedder();\n      if (CoSEConstants.APPLY_LAYOUT) {\n        this.runSpringEmbedder();\n      }\n      return true;\n    };\n    CoSELayout.prototype.tick = function () {\n      this.totalIterations++;\n      if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n        if (this.prunedNodesAll.length > 0) {\n          this.isTreeGrowing = true;\n        } else {\n          return true;\n        }\n      }\n      if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n        if (this.isConverged()) {\n          if (this.prunedNodesAll.length > 0) {\n            this.isTreeGrowing = true;\n          } else {\n            return true;\n          }\n        }\n        this.coolingCycle++;\n        if (this.layoutQuality == 0) {\n          // quality - \"draft\"\n          this.coolingAdjuster = this.coolingCycle;\n        } else if (this.layoutQuality == 1) {\n          // quality - \"default\"\n          this.coolingAdjuster = this.coolingCycle / 3;\n        }\n\n        // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n        this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n        this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n      }\n      // Operations while tree is growing again \n      if (this.isTreeGrowing) {\n        if (this.growTreeIterations % 10 == 0) {\n          if (this.prunedNodesAll.length > 0) {\n            this.graphManager.updateBounds();\n            this.updateGrid();\n            this.growTree(this.prunedNodesAll);\n            // Update nodes that gravity will be applied\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n            this.graphManager.updateBounds();\n            this.updateGrid();\n            if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n          } else {\n            this.isTreeGrowing = false;\n            this.isGrowthFinished = true;\n          }\n        }\n        this.growTreeIterations++;\n      }\n      // Operations after growth is finished\n      if (this.isGrowthFinished) {\n        if (this.isConverged()) {\n          return true;\n        }\n        if (this.afterGrowthIterations % 10 == 0) {\n          this.graphManager.updateBounds();\n          this.updateGrid();\n        }\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n        this.afterGrowthIterations++;\n      }\n      var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n      var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n      this.totalDisplacement = 0;\n      this.graphManager.updateBounds();\n      this.calcSpringForces();\n      this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      this.calcGravitationalForces();\n      this.moveNodes();\n      this.animate();\n      return false; // Layout is not ended yet return false\n    };\n    CoSELayout.prototype.getPositionsData = function () {\n      var allNodes = this.graphManager.getAllNodes();\n      var pData = {};\n      for (var i = 0; i < allNodes.length; i++) {\n        var rect = allNodes[i].rect;\n        var id = allNodes[i].id;\n        pData[id] = {\n          id: id,\n          x: rect.getCenterX(),\n          y: rect.getCenterY(),\n          w: rect.width,\n          h: rect.height\n        };\n      }\n      return pData;\n    };\n    CoSELayout.prototype.runSpringEmbedder = function () {\n      this.initialAnimationPeriod = 25;\n      this.animationPeriod = this.initialAnimationPeriod;\n      var layoutEnded = false;\n\n      // If aminate option is 'during' signal that layout is supposed to start iterating\n      if (FDLayoutConstants.ANIMATE === 'during') {\n        this.emit('layoutstarted');\n      } else {\n        // If aminate option is 'during' tick() function will be called on index.js\n        while (!layoutEnded) {\n          layoutEnded = this.tick();\n        }\n        this.graphManager.updateBounds();\n      }\n    };\n\n    // overrides moveNodes method in FDLayout\n    CoSELayout.prototype.moveNodes = function () {\n      var lNodes = this.getAllNodes();\n      var node;\n\n      // calculate displacement for each node \n      for (var i = 0; i < lNodes.length; i++) {\n        node = lNodes[i];\n        node.calculateDisplacement();\n      }\n      if (Object.keys(this.constraints).length > 0) {\n        this.updateDisplacements();\n      }\n\n      // move each node\n      for (var i = 0; i < lNodes.length; i++) {\n        node = lNodes[i];\n        node.move();\n      }\n    };\n\n    // constraint related methods: initConstraintVariables and updateDisplacements\n\n    // initialize constraint related variables\n    CoSELayout.prototype.initConstraintVariables = function () {\n      var self = this;\n      this.idToNodeMap = new Map();\n      this.fixedNodeSet = new Set();\n      var allNodes = this.graphManager.getAllNodes();\n\n      // fill idToNodeMap\n      for (var i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n        this.idToNodeMap.set(node.id, node);\n      }\n\n      // calculate fixed node weight for given compound node\n      var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n        var nodes = compoundNode.getChild().getNodes();\n        var node;\n        var fixedNodeWeight = 0;\n        for (var i = 0; i < nodes.length; i++) {\n          node = nodes[i];\n          if (node.getChild() == null) {\n            if (self.fixedNodeSet.has(node.id)) {\n              fixedNodeWeight += 100;\n            }\n          } else {\n            fixedNodeWeight += calculateCompoundWeight(node);\n          }\n        }\n        return fixedNodeWeight;\n      };\n      if (this.constraints.fixedNodeConstraint) {\n        // fill fixedNodeSet\n        this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n          self.fixedNodeSet.add(nodeData.nodeId);\n        });\n\n        // assign fixed node weights to compounds if they contain fixed nodes\n        var allNodes = this.graphManager.getAllNodes();\n        var node;\n        for (var i = 0; i < allNodes.length; i++) {\n          node = allNodes[i];\n          if (node.getChild() != null) {\n            var fixedNodeWeight = calculateCompoundWeight(node);\n            if (fixedNodeWeight > 0) {\n              node.fixedNodeWeight = fixedNodeWeight;\n            }\n          }\n        }\n      }\n      if (this.constraints.relativePlacementConstraint) {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        this.dummyToNodeForVerticalAlignment = new Map();\n        this.dummyToNodeForHorizontalAlignment = new Map();\n        this.fixedNodesOnHorizontal = new Set();\n        this.fixedNodesOnVertical = new Set();\n\n        // fill maps and sets\n        this.fixedNodeSet.forEach(function (nodeId) {\n          self.fixedNodesOnHorizontal.add(nodeId);\n          self.fixedNodesOnVertical.add(nodeId);\n        });\n        if (this.constraints.alignmentConstraint) {\n          if (this.constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n            for (var i = 0; i < verticalAlignment.length; i++) {\n              this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n              verticalAlignment[i].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                if (self.fixedNodeSet.has(nodeId)) {\n                  self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                }\n              });\n            }\n          }\n          if (this.constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n            for (var i = 0; i < horizontalAlignment.length; i++) {\n              this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n              horizontalAlignment[i].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                if (self.fixedNodeSet.has(nodeId)) {\n                  self.fixedNodesOnVertical.add(\"dummy\" + i);\n                }\n              });\n            }\n          }\n        }\n        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n          this.shuffle = function (array) {\n            var j, x, i;\n            for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n              j = Math.floor(Math.random() * (i + 1));\n              x = array[i];\n              array[i] = array[j];\n              array[j] = x;\n            }\n            return array;\n          };\n          this.nodesInRelativeHorizontal = [];\n          this.nodesInRelativeVertical = [];\n          this.nodeToRelativeConstraintMapHorizontal = new Map();\n          this.nodeToRelativeConstraintMapVertical = new Map();\n          this.nodeToTempPositionMapHorizontal = new Map();\n          this.nodeToTempPositionMapVertical = new Map();\n\n          // fill arrays and maps\n          this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n            if (constraint.left) {\n              var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n              var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n              if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                  self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                } else {\n                  self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                }\n              }\n              if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                self.nodesInRelativeHorizontal.push(nodeIdRight);\n                self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                  self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                } else {\n                  self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                }\n              }\n              self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({\n                right: nodeIdRight,\n                gap: constraint.gap\n              });\n              self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({\n                left: nodeIdLeft,\n                gap: constraint.gap\n              });\n            } else {\n              var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n              var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n              if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                self.nodesInRelativeVertical.push(nodeIdTop);\n                self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                  self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                } else {\n                  self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                }\n              }\n              if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                self.nodesInRelativeVertical.push(nodeIdBottom);\n                self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                  self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                } else {\n                  self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                }\n              }\n              self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({\n                bottom: nodeIdBottom,\n                gap: constraint.gap\n              });\n              self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({\n                top: nodeIdTop,\n                gap: constraint.gap\n              });\n            }\n          });\n        } else {\n          var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n          var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n          // construct subgraphs from relative placement constraints \n          this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n            if (constraint.left) {\n              var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n              var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n              if (subGraphOnHorizontal.has(left)) {\n                subGraphOnHorizontal.get(left).push(right);\n              } else {\n                subGraphOnHorizontal.set(left, [right]);\n              }\n              if (subGraphOnHorizontal.has(right)) {\n                subGraphOnHorizontal.get(right).push(left);\n              } else {\n                subGraphOnHorizontal.set(right, [left]);\n              }\n            } else {\n              var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n              var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n              if (subGraphOnVertical.has(top)) {\n                subGraphOnVertical.get(top).push(bottom);\n              } else {\n                subGraphOnVertical.set(top, [bottom]);\n              }\n              if (subGraphOnVertical.has(bottom)) {\n                subGraphOnVertical.get(bottom).push(top);\n              } else {\n                subGraphOnVertical.set(bottom, [top]);\n              }\n            }\n          });\n\n          // function to construct components from a given graph \n          // also returns an array that keeps whether each component contains fixed node\n          var constructComponents = function constructComponents(graph, fixedNodes) {\n            var components = [];\n            var isFixed = [];\n            var queue = new LinkedList();\n            var visited = new Set();\n            var count = 0;\n            graph.forEach(function (value, key) {\n              if (!visited.has(key)) {\n                components[count] = [];\n                isFixed[count] = false;\n                var currentNode = key;\n                queue.push(currentNode);\n                visited.add(currentNode);\n                components[count].push(currentNode);\n                while (queue.length != 0) {\n                  currentNode = queue.shift();\n                  if (fixedNodes.has(currentNode)) {\n                    isFixed[count] = true;\n                  }\n                  var neighbors = graph.get(currentNode);\n                  neighbors.forEach(function (neighbor) {\n                    if (!visited.has(neighbor)) {\n                      queue.push(neighbor);\n                      visited.add(neighbor);\n                      components[count].push(neighbor);\n                    }\n                  });\n                }\n                count++;\n              }\n            });\n            return {\n              components: components,\n              isFixed: isFixed\n            };\n          };\n          var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n          this.componentsOnHorizontal = resultOnHorizontal.components;\n          this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n          var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n          this.componentsOnVertical = resultOnVertical.components;\n          this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n        }\n      }\n    };\n\n    // updates node displacements based on constraints\n    CoSELayout.prototype.updateDisplacements = function () {\n      var self = this;\n      if (this.constraints.fixedNodeConstraint) {\n        this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n          var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n          fixedNode.displacementX = 0;\n          fixedNode.displacementY = 0;\n        });\n      }\n      if (this.constraints.alignmentConstraint) {\n        if (this.constraints.alignmentConstraint.vertical) {\n          var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n          for (var i = 0; i < allVerticalAlignments.length; i++) {\n            var totalDisplacementX = 0;\n            for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n              if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                totalDisplacementX = 0;\n                break;\n              }\n              totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n            }\n            var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n            for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n              this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n            }\n          }\n        }\n        if (this.constraints.alignmentConstraint.horizontal) {\n          var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n          for (var i = 0; i < allHorizontalAlignments.length; i++) {\n            var totalDisplacementY = 0;\n            for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n              if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                totalDisplacementY = 0;\n                break;\n              }\n              totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n            }\n            var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n            for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n              this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n            }\n          }\n        }\n      }\n      if (this.constraints.relativePlacementConstraint) {\n        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n          // shuffle array to randomize node processing order\n          if (this.totalIterations % 10 == 0) {\n            this.shuffle(this.nodesInRelativeHorizontal);\n            this.shuffle(this.nodesInRelativeVertical);\n          }\n          this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n            if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n              var displacement = 0;\n              if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n              } else {\n                displacement = self.idToNodeMap.get(nodeId).displacementX;\n              }\n              self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n                if (constraint.right) {\n                  var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                  if (diff < constraint.gap) {\n                    displacement -= constraint.gap - diff;\n                  }\n                } else {\n                  var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                  if (diff < constraint.gap) {\n                    displacement += constraint.gap - diff;\n                  }\n                }\n              });\n              self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n              if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n                  self.idToNodeMap.get(nodeId).displacementX = displacement;\n                });\n              } else {\n                self.idToNodeMap.get(nodeId).displacementX = displacement;\n              }\n            }\n          });\n          this.nodesInRelativeVertical.forEach(function (nodeId) {\n            if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n              var displacement = 0;\n              if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n              } else {\n                displacement = self.idToNodeMap.get(nodeId).displacementY;\n              }\n              self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n                if (constraint.bottom) {\n                  var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                  if (diff < constraint.gap) {\n                    displacement -= constraint.gap - diff;\n                  }\n                } else {\n                  var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                  if (diff < constraint.gap) {\n                    displacement += constraint.gap - diff;\n                  }\n                }\n              });\n              self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n              if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n                  self.idToNodeMap.get(nodeId).displacementY = displacement;\n                });\n              } else {\n                self.idToNodeMap.get(nodeId).displacementY = displacement;\n              }\n            }\n          });\n        } else {\n          for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n            var component = this.componentsOnHorizontal[i];\n            if (this.fixedComponentsOnHorizontal[i]) {\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                  this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                    self.idToNodeMap.get(nodeId).displacementX = 0;\n                  });\n                } else {\n                  this.idToNodeMap.get(component[j]).displacementX = 0;\n                }\n              }\n            } else {\n              var sum = 0;\n              var count = 0;\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                  var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                  sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                  count += actualNodes.length;\n                } else {\n                  sum += this.idToNodeMap.get(component[j]).displacementX;\n                  count++;\n                }\n              }\n              var averageDisplacement = sum / count;\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                  this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                    self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                  });\n                } else {\n                  this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                }\n              }\n            }\n          }\n          for (var i = 0; i < this.componentsOnVertical.length; i++) {\n            var component = this.componentsOnVertical[i];\n            if (this.fixedComponentsOnVertical[i]) {\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                  this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                    self.idToNodeMap.get(nodeId).displacementY = 0;\n                  });\n                } else {\n                  this.idToNodeMap.get(component[j]).displacementY = 0;\n                }\n              }\n            } else {\n              var sum = 0;\n              var count = 0;\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                  var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                  sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                  count += actualNodes.length;\n                } else {\n                  sum += this.idToNodeMap.get(component[j]).displacementY;\n                  count++;\n                }\n              }\n              var averageDisplacement = sum / count;\n              for (var j = 0; j < component.length; j++) {\n                if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                  this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                    self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                  });\n                } else {\n                  this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n      var nodeList = [];\n      var graph;\n      var graphs = this.graphManager.getGraphs();\n      var size = graphs.length;\n      var i;\n      for (i = 0; i < size; i++) {\n        graph = graphs[i];\n        graph.updateConnected();\n        if (!graph.isConnected) {\n          nodeList = nodeList.concat(graph.getNodes());\n        }\n      }\n      return nodeList;\n    };\n    CoSELayout.prototype.createBendpoints = function () {\n      var edges = [];\n      edges = edges.concat(this.graphManager.getAllEdges());\n      var visited = new Set();\n      var i;\n      for (i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        if (!visited.has(edge)) {\n          var source = edge.getSource();\n          var target = edge.getTarget();\n          if (source == target) {\n            edge.getBendpoints().push(new PointD());\n            edge.getBendpoints().push(new PointD());\n            this.createDummyNodesForBendpoints(edge);\n            visited.add(edge);\n          } else {\n            var edgeList = [];\n            edgeList = edgeList.concat(source.getEdgeListToNode(target));\n            edgeList = edgeList.concat(target.getEdgeListToNode(source));\n            if (!visited.has(edgeList[0])) {\n              if (edgeList.length > 1) {\n                var k;\n                for (k = 0; k < edgeList.length; k++) {\n                  var multiEdge = edgeList[k];\n                  multiEdge.getBendpoints().push(new PointD());\n                  this.createDummyNodesForBendpoints(multiEdge);\n                }\n              }\n              edgeList.forEach(function (edge) {\n                visited.add(edge);\n              });\n            }\n          }\n        }\n        if (visited.size == edges.length) {\n          break;\n        }\n      }\n    };\n    CoSELayout.prototype.positionNodesRadially = function (forest) {\n      // We tile the trees to a grid row by row; first tree starts at (0,0)\n      var currentStartingPoint = new Point(0, 0);\n      var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n      var height = 0;\n      var currentY = 0;\n      var currentX = 0;\n      var point = new PointD(0, 0);\n      for (var i = 0; i < forest.length; i++) {\n        if (i % numberOfColumns == 0) {\n          // Start of a new row, make the x coordinate 0, increment the\n          // y coordinate with the max height of the previous row\n          currentX = 0;\n          currentY = height;\n          if (i != 0) {\n            currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n          }\n          height = 0;\n        }\n        var tree = forest[i];\n\n        // Find the center of the tree\n        var centerNode = Layout.findCenterOfTree(tree);\n\n        // Set the staring point of the next tree\n        currentStartingPoint.x = currentX;\n        currentStartingPoint.y = currentY;\n\n        // Do a radial layout starting with the center\n        point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n        if (point.y > height) {\n          height = Math.floor(point.y);\n        }\n        currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n      }\n      this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n    };\n    CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n      var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n      CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n      var bounds = LGraph.calculateBounds(tree);\n      var transform = new Transform();\n      transform.setDeviceOrgX(bounds.getMinX());\n      transform.setDeviceOrgY(bounds.getMinY());\n      transform.setWorldOrgX(startingPoint.x);\n      transform.setWorldOrgY(startingPoint.y);\n      for (var i = 0; i < tree.length; i++) {\n        var node = tree[i];\n        node.transform(transform);\n      }\n      var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n      return transform.inverseTransformPoint(bottomRight);\n    };\n    CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n      // First, position this node by finding its angle.\n      var halfInterval = (endAngle - startAngle + 1) / 2;\n      if (halfInterval < 0) {\n        halfInterval += 180;\n      }\n      var nodeAngle = (halfInterval + startAngle) % 360;\n      var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n      // Make polar to java cordinate conversion.\n      var cos_teta = Math.cos(teta);\n      var x_ = distance * Math.cos(teta);\n      var y_ = distance * Math.sin(teta);\n      node.setCenter(x_, y_);\n\n      // Traverse all neighbors of this node and recursively call this\n      // function.\n      var neighborEdges = [];\n      neighborEdges = neighborEdges.concat(node.getEdges());\n      var childCount = neighborEdges.length;\n      if (parentOfNode != null) {\n        childCount--;\n      }\n      var branchCount = 0;\n      var incEdgesCount = neighborEdges.length;\n      var startIndex;\n      var edges = node.getEdgesBetween(parentOfNode);\n\n      // If there are multiple edges, prune them until there remains only one\n      // edge.\n      while (edges.length > 1) {\n        //neighborEdges.remove(edges.remove(0));\n        var temp = edges[0];\n        edges.splice(0, 1);\n        var index = neighborEdges.indexOf(temp);\n        if (index >= 0) {\n          neighborEdges.splice(index, 1);\n        }\n        incEdgesCount--;\n        childCount--;\n      }\n      if (parentOfNode != null) {\n        //assert edges.length == 1;\n        startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n      } else {\n        startIndex = 0;\n      }\n      var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n      for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n        // Don't back traverse to root node in current tree.\n        if (currentNeighbor == parentOfNode) {\n          continue;\n        }\n        var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n        var childEndAngle = (childStartAngle + stepAngle) % 360;\n        CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n        branchCount++;\n      }\n    };\n    CoSELayout.maxDiagonalInTree = function (tree) {\n      var maxDiagonal = Integer.MIN_VALUE;\n      for (var i = 0; i < tree.length; i++) {\n        var node = tree[i];\n        var diagonal = node.getDiagonal();\n        if (diagonal > maxDiagonal) {\n          maxDiagonal = diagonal;\n        }\n      }\n      return maxDiagonal;\n    };\n    CoSELayout.prototype.calcRepulsionRange = function () {\n      // formula is 2 x (level + 1) x idealEdgeLength\n      return 2 * (this.level + 1) * this.idealEdgeLength;\n    };\n\n    // Tiling methods\n\n    // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n    CoSELayout.prototype.groupZeroDegreeMembers = function () {\n      var self = this;\n      // array of [parent_id x oneDegreeNode_id]\n      var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n      this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n      this.idToDummyNode = {}; // A map of id to dummy node \n\n      var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n      var allNodes = this.graphManager.getAllNodes();\n\n      // Fill zero degree list\n      for (var i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n        var parent = node.getParent();\n        // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n        if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n          zeroDegree.push(node);\n        }\n      }\n\n      // Create a map of parent node and its zero degree members\n      for (var i = 0; i < zeroDegree.length; i++) {\n        var node = zeroDegree[i]; // Zero degree node itself\n        var p_id = node.getParent().id; // Parent id\n\n        if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n        tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n      }\n\n      // If there are at least two nodes at a level, create a dummy compound for them\n      Object.keys(tempMemberGroups).forEach(function (p_id) {\n        if (tempMemberGroups[p_id].length > 1) {\n          var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n          self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n          var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n          // Create a dummy compound with calculated id\n          var dummyCompound = new CoSENode(self.graphManager);\n          dummyCompound.id = dummyCompoundId;\n          dummyCompound.paddingLeft = parent.paddingLeft || 0;\n          dummyCompound.paddingRight = parent.paddingRight || 0;\n          dummyCompound.paddingBottom = parent.paddingBottom || 0;\n          dummyCompound.paddingTop = parent.paddingTop || 0;\n          self.idToDummyNode[dummyCompoundId] = dummyCompound;\n          var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n          var parentGraph = parent.getChild();\n\n          // Add dummy compound to parent the graph\n          parentGraph.add(dummyCompound);\n\n          // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n          for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n            var node = tempMemberGroups[p_id][i];\n            parentGraph.remove(node);\n            dummyParentGraph.add(node);\n          }\n        }\n      });\n    };\n    CoSELayout.prototype.clearCompounds = function () {\n      var childGraphMap = {};\n      var idToNode = {};\n\n      // Get compound ordering by finding the inner one first\n      this.performDFSOnCompounds();\n      for (var i = 0; i < this.compoundOrder.length; i++) {\n        idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n        childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n        // Remove children of compounds\n        this.graphManager.remove(this.compoundOrder[i].getChild());\n        this.compoundOrder[i].child = null;\n      }\n      this.graphManager.resetAllNodes();\n\n      // Tile the removed children\n      this.tileCompoundMembers(childGraphMap, idToNode);\n    };\n    CoSELayout.prototype.clearZeroDegreeMembers = function () {\n      var self = this;\n      var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n      Object.keys(this.memberGroups).forEach(function (id) {\n        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n        tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n        // Set the width and height of the dummy compound as calculated\n        compoundNode.rect.width = tiledZeroDegreePack[id].width;\n        compoundNode.rect.height = tiledZeroDegreePack[id].height;\n        compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n        // compound left and top margings for labels\n        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n        // otherwise they stay as zero\n        compoundNode.labelMarginLeft = 0;\n        compoundNode.labelMarginTop = 0;\n\n        // Update compound bounds considering its label properties and set label margins for left and top\n        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n          var width = compoundNode.rect.width;\n          var height = compoundNode.rect.height;\n          if (compoundNode.labelWidth) {\n            if (compoundNode.labelPosHorizontal == \"left\") {\n              compoundNode.rect.x -= compoundNode.labelWidth;\n              compoundNode.setWidth(width + compoundNode.labelWidth);\n              compoundNode.labelMarginLeft = compoundNode.labelWidth;\n            } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n              compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n              compoundNode.setWidth(compoundNode.labelWidth);\n              compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n            } else if (compoundNode.labelPosHorizontal == \"right\") {\n              compoundNode.setWidth(width + compoundNode.labelWidth);\n            }\n          }\n          if (compoundNode.labelHeight) {\n            if (compoundNode.labelPosVertical == \"top\") {\n              compoundNode.rect.y -= compoundNode.labelHeight;\n              compoundNode.setHeight(height + compoundNode.labelHeight);\n              compoundNode.labelMarginTop = compoundNode.labelHeight;\n            } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n              compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n              compoundNode.setHeight(compoundNode.labelHeight);\n              compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n            } else if (compoundNode.labelPosVertical == \"bottom\") {\n              compoundNode.setHeight(height + compoundNode.labelHeight);\n            }\n          }\n        }\n      });\n    };\n    CoSELayout.prototype.repopulateCompounds = function () {\n      for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n        var lCompoundNode = this.compoundOrder[i];\n        var id = lCompoundNode.id;\n        var horizontalMargin = lCompoundNode.paddingLeft;\n        var verticalMargin = lCompoundNode.paddingTop;\n        var labelMarginLeft = lCompoundNode.labelMarginLeft;\n        var labelMarginTop = lCompoundNode.labelMarginTop;\n        this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n      }\n    };\n    CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n      var self = this;\n      var tiledPack = this.tiledZeroDegreePack;\n      Object.keys(tiledPack).forEach(function (id) {\n        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n        var horizontalMargin = compoundNode.paddingLeft;\n        var verticalMargin = compoundNode.paddingTop;\n        var labelMarginLeft = compoundNode.labelMarginLeft;\n        var labelMarginTop = compoundNode.labelMarginTop;\n\n        // Adjust the positions of nodes wrt its compound\n        self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n      });\n    };\n    CoSELayout.prototype.getToBeTiled = function (node) {\n      var id = node.id;\n      //firstly check the previous results\n      if (this.toBeTiled[id] != null) {\n        return this.toBeTiled[id];\n      }\n\n      //only compound nodes are to be tiled\n      var childGraph = node.getChild();\n      if (childGraph == null) {\n        this.toBeTiled[id] = false;\n        return false;\n      }\n      var children = childGraph.getNodes(); // Get the children nodes\n\n      //a compound node is not to be tiled if all of its compound children are not to be tiled\n      for (var i = 0; i < children.length; i++) {\n        var theChild = children[i];\n        if (this.getNodeDegree(theChild) > 0) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n\n        //pass the children not having the compound structure\n        if (theChild.getChild() == null) {\n          this.toBeTiled[theChild.id] = false;\n          continue;\n        }\n        if (!this.getToBeTiled(theChild)) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n      }\n      this.toBeTiled[id] = true;\n      return true;\n    };\n\n    // Get degree of a node depending of its edges and independent of its children\n    CoSELayout.prototype.getNodeDegree = function (node) {\n      var id = node.id;\n      var edges = node.getEdges();\n      var degree = 0;\n\n      // For the edges connected\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        if (edge.getSource().id !== edge.getTarget().id) {\n          degree = degree + 1;\n        }\n      }\n      return degree;\n    };\n\n    // Get degree of a node with its children\n    CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n      var degree = this.getNodeDegree(node);\n      if (node.getChild() == null) {\n        return degree;\n      }\n      var children = node.getChild().getNodes();\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        degree += this.getNodeDegreeWithChildren(child);\n      }\n      return degree;\n    };\n    CoSELayout.prototype.performDFSOnCompounds = function () {\n      this.compoundOrder = [];\n      this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n    };\n    CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.getChild() != null) {\n          this.fillCompexOrderByDFS(child.getChild().getNodes());\n        }\n        if (this.getToBeTiled(child)) {\n          this.compoundOrder.push(child);\n        }\n      }\n    };\n\n    /**\n    * This method places each zero degree member wrt given (x,y) coordinates (top left).\n    */\n    CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n      x += compoundHorizontalMargin + compoundLabelMarginLeft;\n      y += compoundVerticalMargin + compoundLabelMarginTop;\n      var left = x;\n      for (var i = 0; i < organization.rows.length; i++) {\n        var row = organization.rows[i];\n        x = left;\n        var maxHeight = 0;\n        for (var j = 0; j < row.length; j++) {\n          var lnode = row[j];\n          lnode.rect.x = x; // + lnode.rect.width / 2;\n          lnode.rect.y = y; // + lnode.rect.height / 2;\n\n          x += lnode.rect.width + organization.horizontalPadding;\n          if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n        }\n        y += maxHeight + organization.verticalPadding;\n      }\n    };\n    CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n      var self = this;\n      this.tiledMemberPack = [];\n      Object.keys(childGraphMap).forEach(function (id) {\n        // Get the compound node\n        var compoundNode = idToNode[id];\n        self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n        compoundNode.rect.width = self.tiledMemberPack[id].width;\n        compoundNode.rect.height = self.tiledMemberPack[id].height;\n        compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n        // compound left and top margings for labels\n        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n        // otherwise they stay as zero\n        compoundNode.labelMarginLeft = 0;\n        compoundNode.labelMarginTop = 0;\n\n        // Update compound bounds considering its label properties and set label margins for left and top\n        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n          var width = compoundNode.rect.width;\n          var height = compoundNode.rect.height;\n          if (compoundNode.labelWidth) {\n            if (compoundNode.labelPosHorizontal == \"left\") {\n              compoundNode.rect.x -= compoundNode.labelWidth;\n              compoundNode.setWidth(width + compoundNode.labelWidth);\n              compoundNode.labelMarginLeft = compoundNode.labelWidth;\n            } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n              compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n              compoundNode.setWidth(compoundNode.labelWidth);\n              compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n            } else if (compoundNode.labelPosHorizontal == \"right\") {\n              compoundNode.setWidth(width + compoundNode.labelWidth);\n            }\n          }\n          if (compoundNode.labelHeight) {\n            if (compoundNode.labelPosVertical == \"top\") {\n              compoundNode.rect.y -= compoundNode.labelHeight;\n              compoundNode.setHeight(height + compoundNode.labelHeight);\n              compoundNode.labelMarginTop = compoundNode.labelHeight;\n            } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n              compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n              compoundNode.setHeight(compoundNode.labelHeight);\n              compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n            } else if (compoundNode.labelPosVertical == \"bottom\") {\n              compoundNode.setHeight(height + compoundNode.labelHeight);\n            }\n          }\n        }\n      });\n    };\n    CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n      var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n      var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n      var organization = {\n        rows: [],\n        rowWidth: [],\n        rowHeight: [],\n        width: 0,\n        height: minWidth,\n        // assume minHeight equals to minWidth\n        verticalPadding: verticalPadding,\n        horizontalPadding: horizontalPadding,\n        centerX: 0,\n        centerY: 0\n      };\n\n      // Sort the nodes in ascending order of their areas\n      nodes.sort(function (n1, n2) {\n        if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n        if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n        return 0;\n      });\n\n      // Create the organization -> calculate compound center\n      var sumCenterX = 0;\n      var sumCenterY = 0;\n      for (var i = 0; i < nodes.length; i++) {\n        var lNode = nodes[i];\n        sumCenterX += lNode.getCenterX();\n        sumCenterY += lNode.getCenterY();\n      }\n      organization.centerX = sumCenterX / nodes.length;\n      organization.centerY = sumCenterY / nodes.length;\n\n      // Create the organization -> tile members\n      for (var i = 0; i < nodes.length; i++) {\n        var lNode = nodes[i];\n        if (organization.rows.length == 0) {\n          this.insertNodeToRow(organization, lNode, 0, minWidth);\n        } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n          this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n        } else {\n          this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n        }\n        this.shiftToLastRow(organization);\n      }\n      return organization;\n    };\n    CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n      var minCompoundSize = minWidth;\n\n      // Add new row if needed\n      if (rowIndex == organization.rows.length) {\n        var secondDimension = [];\n        organization.rows.push(secondDimension);\n        organization.rowWidth.push(minCompoundSize);\n        organization.rowHeight.push(0);\n      }\n\n      // Update row width\n      var w = organization.rowWidth[rowIndex] + node.rect.width;\n      if (organization.rows[rowIndex].length > 0) {\n        w += organization.horizontalPadding;\n      }\n      organization.rowWidth[rowIndex] = w;\n      // Update compound width\n      if (organization.width < w) {\n        organization.width = w;\n      }\n\n      // Update height\n      var h = node.rect.height;\n      if (rowIndex > 0) h += organization.verticalPadding;\n      var extraHeight = 0;\n      if (h > organization.rowHeight[rowIndex]) {\n        extraHeight = organization.rowHeight[rowIndex];\n        organization.rowHeight[rowIndex] = h;\n        extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n      }\n      organization.height += extraHeight;\n\n      // Insert node\n      organization.rows[rowIndex].push(node);\n    };\n\n    //Scans the rows of an organization and returns the one with the min width\n    CoSELayout.prototype.getShortestRowIndex = function (organization) {\n      var r = -1;\n      var min = Number.MAX_VALUE;\n      for (var i = 0; i < organization.rows.length; i++) {\n        if (organization.rowWidth[i] < min) {\n          r = i;\n          min = organization.rowWidth[i];\n        }\n      }\n      return r;\n    };\n\n    //Scans the rows of an organization and returns the one with the max width\n    CoSELayout.prototype.getLongestRowIndex = function (organization) {\n      var r = -1;\n      var max = Number.MIN_VALUE;\n      for (var i = 0; i < organization.rows.length; i++) {\n        if (organization.rowWidth[i] > max) {\n          r = i;\n          max = organization.rowWidth[i];\n        }\n      }\n      return r;\n    };\n\n    /**\n    * This method checks whether adding extra width to the organization violates\n    * the aspect ratio(1) or not.\n    */\n    CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n      var sri = this.getShortestRowIndex(organization);\n      if (sri < 0) {\n        return true;\n      }\n      var min = organization.rowWidth[sri];\n      if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n      var hDiff = 0;\n\n      // Adding to an existing row\n      if (organization.rowHeight[sri] < extraHeight) {\n        if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n      }\n      var add_to_row_ratio;\n      if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n        add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n      } else {\n        add_to_row_ratio = (organization.height + hDiff) / organization.width;\n      }\n\n      // Adding a new row for this node\n      hDiff = extraHeight + organization.verticalPadding;\n      var add_new_row_ratio;\n      if (organization.width < extraWidth) {\n        add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n      } else {\n        add_new_row_ratio = (organization.height + hDiff) / organization.width;\n      }\n      if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n      if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n      return add_to_row_ratio < add_new_row_ratio;\n    };\n\n    //If moving the last node from the longest row and adding it to the last\n    //row makes the bounding box smaller, do it.\n    CoSELayout.prototype.shiftToLastRow = function (organization) {\n      var longest = this.getLongestRowIndex(organization);\n      var last = organization.rowWidth.length - 1;\n      var row = organization.rows[longest];\n      var node = row[row.length - 1];\n      var diff = node.width + organization.horizontalPadding;\n\n      // Check if there is enough space on the last row\n      if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n        // Remove the last element of the longest row\n        row.splice(-1, 1);\n\n        // Push it to the last row\n        organization.rows[last].push(node);\n        organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n        organization.rowWidth[last] = organization.rowWidth[last] + diff;\n        organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n        // Update heights of the organization\n        var maxHeight = Number.MIN_VALUE;\n        for (var i = 0; i < row.length; i++) {\n          if (row[i].height > maxHeight) maxHeight = row[i].height;\n        }\n        if (longest > 0) maxHeight += organization.verticalPadding;\n        var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n        organization.rowHeight[longest] = maxHeight;\n        if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n        var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n        organization.height += finalTotal - prevTotal;\n        this.shiftToLastRow(organization);\n      }\n    };\n    CoSELayout.prototype.tilingPreLayout = function () {\n      if (CoSEConstants.TILE) {\n        // Find zero degree nodes and create a compound for each level\n        this.groupZeroDegreeMembers();\n        // Tile and clear children of each compound\n        this.clearCompounds();\n        // Separately tile and clear zero degree nodes for each level\n        this.clearZeroDegreeMembers();\n      }\n    };\n    CoSELayout.prototype.tilingPostLayout = function () {\n      if (CoSEConstants.TILE) {\n        this.repopulateZeroDegreeMembers();\n        this.repopulateCompounds();\n      }\n    };\n\n    // -----------------------------------------------------------------------------\n    // Section: Tree Reduction methods\n    // -----------------------------------------------------------------------------\n    // Reduce trees \n    CoSELayout.prototype.reduceTrees = function () {\n      var prunedNodesAll = [];\n      var containsLeaf = true;\n      var node;\n      while (containsLeaf) {\n        var allNodes = this.graphManager.getAllNodes();\n        var prunedNodesInStepTemp = [];\n        containsLeaf = false;\n        for (var i = 0; i < allNodes.length; i++) {\n          node = allNodes[i];\n          if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n            if (CoSEConstants.PURE_INCREMENTAL) {\n              var otherEnd = node.getEdges()[0].getOtherEnd(node);\n              var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n              prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n            } else {\n              prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n            }\n            containsLeaf = true;\n          }\n        }\n        if (containsLeaf == true) {\n          var prunedNodesInStep = [];\n          for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n            if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n              prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n              prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n            }\n          }\n          prunedNodesAll.push(prunedNodesInStep);\n          this.graphManager.resetAllNodes();\n          this.graphManager.resetAllEdges();\n        }\n      }\n      this.prunedNodesAll = prunedNodesAll;\n    };\n\n    // Grow tree one step \n    CoSELayout.prototype.growTree = function (prunedNodesAll) {\n      var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n      var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n      var nodeData;\n      for (var i = 0; i < prunedNodesInStep.length; i++) {\n        nodeData = prunedNodesInStep[i];\n        this.findPlaceforPrunedNode(nodeData);\n        nodeData[2].add(nodeData[0]);\n        nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n      }\n      prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    };\n\n    // Find an appropriate position to replace pruned node, this method can be improved\n    CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n      var gridForPrunedNode;\n      var nodeToConnect;\n      var prunedNode = nodeData[0];\n      if (prunedNode == nodeData[1].source) {\n        nodeToConnect = nodeData[1].target;\n      } else {\n        nodeToConnect = nodeData[1].source;\n      }\n      if (CoSEConstants.PURE_INCREMENTAL) {\n        prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n      } else {\n        var startGridX = nodeToConnect.startX;\n        var finishGridX = nodeToConnect.finishX;\n        var startGridY = nodeToConnect.startY;\n        var finishGridY = nodeToConnect.finishY;\n        var upNodeCount = 0;\n        var downNodeCount = 0;\n        var rightNodeCount = 0;\n        var leftNodeCount = 0;\n        var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n        if (startGridY > 0) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n          }\n        }\n        if (finishGridX < this.grid.length - 1) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n          }\n        }\n        if (finishGridY < this.grid[0].length - 1) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n          }\n        }\n        if (startGridX > 0) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n          }\n        }\n        var min = Integer.MAX_VALUE;\n        var minCount;\n        var minIndex;\n        for (var j = 0; j < controlRegions.length; j++) {\n          if (controlRegions[j] < min) {\n            min = controlRegions[j];\n            minCount = 1;\n            minIndex = j;\n          } else if (controlRegions[j] == min) {\n            minCount++;\n          }\n        }\n        if (minCount == 3 && min == 0) {\n          if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n            gridForPrunedNode = 1;\n          } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 0;\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 3;\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 2;\n          }\n        } else if (minCount == 2 && min == 0) {\n          var random = Math.floor(Math.random() * 2);\n          if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n            ;\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 1;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else {\n            if (random == 0) {\n              gridForPrunedNode = 2;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          }\n        } else if (minCount == 4 && min == 0) {\n          var random = Math.floor(Math.random() * 4);\n          gridForPrunedNode = random;\n        } else {\n          gridForPrunedNode = minIndex;\n        }\n        if (gridForPrunedNode == 0) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n        } else if (gridForPrunedNode == 1) {\n          prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        } else if (gridForPrunedNode == 2) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n        } else {\n          prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        }\n      }\n    };\n    module.exports = CoSELayout;\n\n    /***/\n  }), (/* 8 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var coseBase = {};\n    coseBase.layoutBase = __webpack_require__(0);\n    coseBase.CoSEConstants = __webpack_require__(1);\n    coseBase.CoSEEdge = __webpack_require__(2);\n    coseBase.CoSEGraph = __webpack_require__(3);\n    coseBase.CoSEGraphManager = __webpack_require__(4);\n    coseBase.CoSELayout = __webpack_require__(7);\n    coseBase.CoSENode = __webpack_require__(5);\n    coseBase.ConstraintHandler = __webpack_require__(6);\n    module.exports = coseBase;\n\n    /***/\n  }\n  /******/)]);\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_0__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","FDLayoutConstants","CoSEConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TRANSFORM_ON_CONSTRAINT_HANDLING","ENFORCE_CONSTRAINTS","APPLY_LAYOUT","RELAX_MOVEMENT_ON_CONSTRAINTS","TREE_REDUCTION_ON_INCREMENTAL","PURE_INCREMENTAL","DEFAULT_INCREMENTAL","FDLayoutEdge","CoSEEdge","source","target","vEdge","create","LGraph","CoSEGraph","parent","graphMgr","vGraph","LGraphManager","CoSEGraphManager","layout","FDLayoutNode","IMath","CoSENode","gm","loc","size","vNode","calculateDisplacement","graphManager","getLayout","getChild","fixedNodeWeight","displacementX","coolingFactor","springForceX","repulsionForceX","gravitationForceX","displacementY","springForceY","repulsionForceY","gravitationForceY","noOfChildren","Math","abs","maxNodeDisplacement","sign","child","getNodes","length","propogateDisplacementToChildren","dX","dY","nodes","node","move","moveBy","totalDisplacement","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","_toConsumableArray","arr","Array","isArray","arr2","from","LinkedList","Matrix","SVD","ConstraintHandler","handleConstraints","constraints","fixedNodeConstraint","alignmentConstraint","relativePlacementConstraint","idToNodeMap","Map","nodeIndexes","xCoords","yCoords","allNodes","getAllNodes","index","set","id","push","getCenterX","getCenterY","forEach","constraint","gap","left","getWidth","right","top","getHeight","bottom","calculatePositionDiff","pos1","pos2","x","y","calculateAvgPosition","nodeIdSet","xPosSum","yPosSum","nodeId","findAppropriatePositionForRelativePlacement","graph","direction","fixedNodes","dummyPositions","componentSources","setUnion","setA","setB","union","Set","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","done","elem","add","err","return","inDegrees","key","adjacent","positionMap","pastMap","queue","has","Number","NEGATIVE_INFINITY","component","fixedIds","position","fixedId","_position","_loop","currentNode","shift","neighbors","neighbor","fixedPosition","diff","sinkNodes","_components","isFixedComponent","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","isExist","existAt","concat","ele","minBefore","POSITIVE_INFINITY","minAfter","maxBefore","maxAfter","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","posBefore","posAfter","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","_nodeId","applyReflectionForRelativePlacement","relativePlacementConstraints","reflectOnY","notReflectOnY","reflectOnX","notReflectOnX","_i","_i2","_i3","findComponents","components","visited","count","_currentNode","dagToUndirected","dag","undirected","dagToReversed","reversed","targetMatrix","sourceMatrix","standardTransformation","reflectionType","dagUndirected","nodeData","vertical","verticalAlign","_loop2","_i4","alignmentSet","intersection","filter","xPos","values","horizontal","horizontalAlign","_loop3","_i5","yPos","largestComponentSize","largestComponentIndex","_i6","subGraphOnHorizontal","subGraphOnVertical","constraintsInlargestComponent","positionMapHorizontal","positionMapVertical","transformationMatrix","targetMatrixTranspose","transpose","sourceMatrixTranspose","_i7","multGamma","tempMatrix","multMat","SVDResult","svd","V","U","_i8","temp1","temp2","temp3","dotProduct","translationAmount","posInTheory","posDesired","posDiff","xAlign","_loop4","_i9","yAlign","_loop5","_i10","nodeToDummyForVerticalAlignment","nodeToDummyForHorizontalAlignment","dummyToNodeForVerticalAlignment","dummyToNodeForHorizontalAlignment","dummyPositionsForVerticalAlignment","dummyPositionsForHorizontalAlignment","fixedNodesOnHorizontal","fixedNodesOnVertical","verticalAlignment","_loop6","_i11","horizontalAlignment","_loop7","_i12","dagOnHorizontal","dagOnVertical","_loop8","sourceId","targetNode","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","keys","_step5","undirectedOnHorizontal","undirectedOnVertical","componentsOnHorizontal","componentsOnVertical","reversedDagOnHorizontal","reversedDagOnVertical","componentSourcesOnHorizontal","componentSourcesOnVertical","_loop9","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","_loop10","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_iterator7","_step7","_i13","_node","setCenter","FDLayout","LayoutConstants","Point","PointD","DimensionD","Layout","Integer","IGeometry","Transform","CoSELayout","toBeTiled","newGraphManager","newGraph","newNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","initSpringEmbedder","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","positionNodesRandomly","initConstraintVariables","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","rect","w","width","h","height","layoutEnded","ANIMATE","emit","lNodes","updateDisplacements","self","fixedNodeSet","calculateCompoundWeight","compoundNode","shuffle","array","j","floor","random","nodesInRelativeHorizontal","nodesInRelativeVertical","nodeToRelativeConstraintMapHorizontal","nodeToRelativeConstraintMapVertical","nodeToTempPositionMapHorizontal","nodeToTempPositionMapVertical","nodeIdLeft","nodeIdRight","includes","nodeIdTop","nodeIdBottom","constructComponents","isFixed","resultOnHorizontal","fixedComponentsOnHorizontal","resultOnVertical","fixedComponentsOnVertical","fixedNode","allVerticalAlignments","totalDisplacementX","averageDisplacementX","allHorizontalAlignments","totalDisplacementY","averageDisplacementY","displacement","sum","actualNodes","averageDisplacement","nodeList","graphs","getGraphs","updateConnected","isConnected","edges","getAllEdges","edge","getSource","getTarget","getBendpoints","createDummyNodesForBendpoints","edgeList","getEdgeListToNode","k","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","indexOf","stepAngle","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","getToBeTiled","p_id","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","tileNodes","centerX","centerY","labelMarginLeft","labelMarginTop","NODE_DIMENSIONS_INCLUDE_LABELS","labelWidth","labelPosHorizontal","setWidth","labelHeight","labelPosVertical","setHeight","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","compoundLabelMarginLeft","compoundLabelMarginTop","rows","row","maxHeight","lnode","horizontalPadding","verticalPadding","minWidth","rowWidth","rowHeight","sort","n1","n2","sumCenterX","sumCenterY","lNode","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","secondDimension","extraHeight","r","min","MAX_VALUE","getLongestRowIndex","extraWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","otherEnd","relativePosition","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","coseBase","layoutBase"],"sources":["/home/lbarbosa/Documents/Github/murabei-st-cytoscape/murabei_st_cytoscape/frontend/node_modules/cose-base/cose-base.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __webpack_require__(1);\nvar LinkedList = __webpack_require__(0).LinkedList;\nvar Matrix = __webpack_require__(0).Matrix;\nvar SVD = __webpack_require__(0).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar ConstraintHandler = __webpack_require__(6);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar DimensionD = __webpack_require__(0).DimensionD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\nvar LinkedList = __webpack_require__(0).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(7);\ncoseBase.CoSENode = __webpack_require__(5);\ncoseBase.ConstraintHandler = __webpack_require__(6);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}